–ú–Ü–ù–Ü–°–¢–ï–†–°–¢–í–û –û–°–í–Ü–¢–ò –Ü –ù–ê–£–ö–ò –£–ö–†–ê–á–ù–ò

 
–•–ê–†–ö–Ü–í–°–¨–ö–ò–ô –ù–ê–¶–Ü–û–ù–ê–õ–¨–ù–ò–ô
–£–ù–Ü–í–ï–†–°–ò–¢–ï–¢ –†–ê–î–Ü–û–ï–õ–ï–ö–¢–†–û–ù–Ü–ö–ò



–ö–ê–§–ï–î–†–ê –ü–Ü
  

–ó–í–Ü–¢
–∑ –ª–∞–±–æ—Ä–∞—Ç–æ—Ä–Ω–æ—ó —Ä–æ–±–æ—Ç–∏ ‚Ññ3
–∑ –¥–∏—Å—Ü–∏–ø–ª—ñ–Ω–∏ ¬´–ê–ù–ê–õ–Ü–ó –¢–ê –†–ï–§–ê–ö–¢–û–†–ò–ù–ì 
–ö–û–î–£ –ü–†–û–ì–†–ê–ú–ù–û–ì–û –ó–ê–ë–ï–ó–ü–ï–ß–ï–ù–ù–Ø¬ª
–∑–∞ —Ç–µ–º–æ—é ¬´–†–û–ó–†–û–ë–ö–ê –ë–Ü–ó–ù–ï–°-–õ–û–ì–Ü–ö–ò –¢–ê 
–§–£–ù–ö–¶–Ü–ô –ê–î–ú–Ü–ù–Ü–°–¢–†–£–í–ê–ù–ù–Ø –°–ï–†–í–ï–†–ù–û–á –ß–ê–°–¢–ò–ù–ò –ü–†–û–ì–†–ê–ú–ù–û–á 
–°–ò–°–¢–ï–ú–ò¬ª


–í–∏–∫–æ–Ω–∞–ª–∞:                                          	             
—Å—Ç. –≥—Ä. –ü–ó–ü–Ü-23-6
–ö–∞—á—É—Ä–∞ –î—ñ–∞–Ω–∞	–ü—Ä–∏–π–Ω—è–≤:	
–ê—Å–∏—Å—Ç–µ–Ω—Ç –∫–∞—Ñ–µ–¥—Ä–∏ –ü–Ü
–î–∞—à–µ–Ω–∫–æ–≤ –î. –°.






–•–∞—Ä–∫—ñ–≤ 2025
3.1 –ú–µ—Ç–∞ –∑–∞–Ω—è—Ç—Ç—è

	–†–æ–∑—Ä–æ–±–∫–∞ –±—ñ–∑–Ω–µ—Å-–ª–æ–≥—ñ–∫–∏ —Ç–∞ —Ñ—É–Ω–∫—Ü—ñ–π –∞–¥–º—ñ–Ω—ñ—Å—Ç—Ä—É–≤–∞–Ω–Ω—è —Å–µ—Ä–≤–µ—Ä–Ω–æ—ó —á–∞—Å—Ç–∏–Ω–∏ –ø—Ä–æ–≥—Ä–∞–º–Ω–æ—ó —Å–∏—Å—Ç–µ–º–∏
	
	3.2 –í–∏–∫–æ–Ω–∞–Ω–Ω—è –∑–∞–≤–¥–∞–Ω–Ω—è
	3.2.1 –†–æ–∑—Ä–æ–±–∫–∞ –±—ñ–∑–Ω–µ—Å –ª–æ–≥—ñ–∫–∏ —Å–µ—Ä–≤–µ—Ä–Ω–æ—ó —á–∞—Å—Ç–∏–Ω–∏
	3.2.1.1 –ó–∞–ø–∏—Å –ø–æ–∫–∞–∑–Ω–∏–∫—ñ–≤ —Å–µ–Ω—Å–æ—Ä—ñ–≤

–£ –ø—Ä–æ—Ü–µ—Å—ñ —Ä–æ–∑—Ä–æ–±–∫–∏ —Å–µ—Ä–≤–µ—Ä–Ω–æ—ó —á–∞—Å—Ç–∏–Ω–∏ –±—É–ª–æ —Ä–µ–∞–ª—ñ–∑–æ–≤–∞–Ω–æ –±—ñ–∑–Ω–µ—Å-–ª–æ–≥—ñ–∫—É –¥–ª—è –ø—Ä–∏–π–º–∞–Ω–Ω—è —Ç–∞ –æ–±—Ä–æ–±–∫–∏ –ø–æ–∫–∞–∑–Ω–∏–∫—ñ–≤ —Å–µ–Ω—Å–æ—Ä—ñ–≤. –ó–∞–≥–∞–ª—å–Ω–∞ —Å—Ö–µ–º–∞ —Ü—å–æ–≥–æ –ø—Ä–æ—Ü–µ—Å—É –≤—ñ–¥–ø–æ–≤—ñ–¥–∞—î –¥—ñ–∞–≥—Ä–∞–º—ñ –Ω–∞ —Ä–∏—Å—É–Ω–∫—É 3.1, –¥–µ –ø—Ä–æ–¥–µ–º–æ–Ω—Å—Ç—Ä–æ–≤–∞–Ω–æ —à–ª—è—Ö –¥–∞–Ω–∏—Ö –≤—ñ–¥ –º–æ–º–µ–Ω—Ç—É —ó—Ö –æ—Ç—Ä–∏–º–∞–Ω–Ω—è –¥–æ –º–æ–∂–ª–∏–≤–æ–≥–æ —Ñ–æ—Ä–º—É–≤–∞–Ω–Ω—è —Å–ø–æ–≤—ñ—â–µ–Ω—å —É –≤–∏–ø–∞–¥–∫—É –ø–æ—Ä—É—à–µ–Ω–Ω—è –ø–æ—Ä–æ–≥–æ–≤–∏—Ö –∑–Ω–∞—á–µ–Ω—å.
–ü—ñ—Å–ª—è –Ω–∞–¥—Ö–æ–¥–∂–µ–Ω–Ω—è –¥–∞–Ω–∏—Ö –≤—ñ–¥ –¥–∞—Ç—á–∏–∫–∞ —Å–µ—Ä–≤–µ—Ä —Å–ø–æ—á–∞—Ç–∫—É –≤–∏–∫–æ–Ω—É—î —ñ–¥–µ–Ω—Ç–∏—Ñ—ñ–∫–∞—Ü—ñ—é —Å–µ–Ω—Å–æ—Ä–∞ –∑–∞ –π–æ–≥–æ —Å–µ—Ä—ñ–π–Ω–∏–º –Ω–æ–º–µ—Ä–æ–º. –Ø–∫—â–æ —Ç–∞–∫–æ–≥–æ —Å–µ–Ω—Å–æ—Ä–∞ –Ω–µ —ñ—Å–Ω—É—î, —Ñ–æ—Ä–º—É–≤–∞–Ω–Ω—è –ø–æ–∫–∞–∑–Ω–∏–∫–∞ –Ω–µ–º–æ–∂–ª–∏–≤–µ, —ñ –≤—ñ–¥–ø–æ–≤—ñ–¥–Ω–æ –ø—Ä–æ—Ü–µ—Å –∑–∞–≤–µ—Ä—à—É—î—Ç—å—Å—è –ø–æ–º–∏–ª–∫–æ—é ‚Äî —Ü–µ–π —Å—Ü–µ–Ω–∞—Ä—ñ–π –Ω–∞ –¥—ñ–∞–≥—Ä–∞–º—ñ –ø–æ–∑–Ω–∞—á–µ–Ω–æ —è–∫ ¬´–°–µ–Ω—Å–æ—Ä –Ω–µ —ñ–¥–µ–Ω—Ç–∏—Ñ—ñ–∫–æ–≤–∞–Ω–æ¬ª. –£ —Ä–∞–∑—ñ —É—Å–ø—ñ—à–Ω–æ—ó —ñ–¥–µ–Ω—Ç–∏—Ñ—ñ–∫–∞—Ü—ñ—ó —Å–∏—Å—Ç–µ–º–∞ –ø–µ—Ä–µ—Ö–æ–¥–∏—Ç—å –¥–æ –≤–∞–ª—ñ–¥–∞—Ü—ñ—ó –≤–∏–º—ñ—Ä—è–Ω–æ–≥–æ –∑–Ω–∞—á–µ–Ω–Ω—è. –î–ª—è —Ü—å–æ–≥–æ –≤–∏–∫–ª–∏–∫–∞—î—Ç—å—Å—è —Å–µ—Ä–≤—ñ—Å thresholdService, —è–∫–∏–π –≤–∏–∑–Ω–∞—á–∞—î, —á–∏ –≤–∏—Ö–æ–¥–∏—Ç—å –æ—Ç—Ä–∏–º–∞–Ω–∏–π –ø–æ–∫–∞–∑–Ω–∏–∫ –∑–∞ –º–µ–∂—ñ –≤—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—Ö –ø–æ—Ä–æ–≥–æ–≤–∏—Ö –∑–Ω–∞—á–µ–Ω—å. –Ø–∫—â–æ –∑–Ω–∞—á–µ–Ω–Ω—è —î –∫–æ—Ä–µ–∫—Ç–Ω–∏–º, —Å–∏—Å—Ç–µ–º–∞ –ø—Ä–æ–¥–æ–≤–∂—É—î —Ä–æ–±–æ—Ç—É; —è–∫—â–æ –∂ –ø–æ—Ä—É—à–µ–Ω–Ω—è –ø—Ä–∏—Å—É—Ç–Ω—ñ, –≤–æ–Ω–∏ —Ñ—ñ–∫—Å—É—é—Ç—å—Å—è —É –≤–∏–≥–ª—è–¥—ñ —Å–ø–∏—Å–∫—É –≤—ñ–¥–ø–æ–≤—ñ–¥–Ω–∏—Ö –ø–æ—Ä–æ–≥–æ–≤–∏—Ö –≤—ñ–¥—Ö–∏–ª–µ–Ω—å.
–í–∞–∂–ª–∏–≤–∏–º –∞—Å–ø–µ–∫—Ç–æ–º —Ä–µ–∞–ª—ñ–∑–∞—Ü—ñ—ó —î –º–µ—Ö–∞–Ω—ñ–∑–º –æ–±—á–∏—Å–ª–µ–Ω–Ω—è –ø–æ–∫–∞–∑–Ω–∏–∫–∞ —è–∫–æ—Å—Ç—ñ –¥–∞–Ω–∏—Ö (quality). –ó–∞ –∑–∞–º–æ–≤—á—É–≤–∞–Ω–Ω—è–º —è–∫—ñ—Å—Ç—å –¥–æ—Ä—ñ–≤–Ω—é—î 1.0, –ø—Ä–æ—Ç–µ —è–∫—â–æ –ø–æ—Ä—É—à–µ–Ω–Ω—è –≤—Å–µ –∂ –∑–∞—Ñ—ñ–∫—Å–æ–≤–∞–Ω—ñ, —Å–∏—Å—Ç–µ–º–∞ –∫–æ—Ä–∏–≥—É—î —Ü–µ–π –ø–æ–∫–∞–∑–Ω–∏–∫ –∑–∞–ª–µ–∂–Ω–æ –≤—ñ–¥ —Å–µ—Ä–π–æ–∑–Ω–æ—Å—Ç—ñ –≤—ñ–¥—Ö–∏–ª–µ–Ω–Ω—è. –î–ª—è —Ü—å–æ–≥–æ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î—Ç—å—Å—è –æ–∫—Ä–µ–º–∏–π –º–µ—Ç–æ–¥ getSeverityWeight(), —è–∫–∏–π –ø–æ–≤–µ—Ä—Ç–∞—î –≤–∞–≥–æ–≤–∏–π –∫–æ–µ—Ñ—ñ—Ü—ñ—î–Ω—Ç –¥–ª—è –∫–æ–∂–Ω–æ–≥–æ —Ä—ñ–≤–Ω—è —Å–µ—Ä–π–æ–∑–Ω–æ—Å—Ç—ñ. –ù–∞–ø—Ä–∏–∫–ª–∞–¥, –ø–æ—Ä—É—à–µ–Ω–Ω—è —Ä—ñ–≤–Ω—è LOW –º–∞—î –≤–∞–≥—É 0.1, MEDIUM ‚Äî 0.3, HIGH ‚Äî 0.6, –∞ CRITICAL ‚Äî 1.0. –í—ñ–¥–ø–æ–≤—ñ–¥–Ω–æ, —á–∏–º —Å–µ—Ä–π–æ–∑–Ω—ñ—à–µ –ø–æ—Ä—É—à–µ–Ω–Ω—è, —Ç–∏–º –º–µ–Ω—à–∏–º —Å—Ç–∞—î –∑–Ω–∞—á–µ–Ω–Ω—è quality, —â–æ —Ñ–∞–∫—Ç–∏—á–Ω–æ –≤—ñ–¥–æ–±—Ä–∞–∂–∞—î –Ω–µ–¥–æ–≤—ñ—Ä—É —Å–∏—Å—Ç–µ–º–∏ –¥–æ –æ—Ç—Ä–∏–º–∞–Ω–æ–≥–æ –≤–∏–º—ñ—Ä—é–≤–∞–Ω–Ω—è. –§–æ—Ä–º—É–ª–∞ –æ–±—á–∏—Å–ª–µ–Ω–Ω—è: –∑—ñ –∑–Ω–∞—á–µ–Ω–Ω—è 1.0 –≤—ñ–¥–Ω—ñ–º–∞—î—Ç—å—Å—è –º–∞–∫—Å–∏–º–∞–ª—å–Ω–∞ –≤–∞–≥–∞ —Å–µ—Ä–µ–¥ —É—Å—ñ—Ö –∑–Ω–∞–π–¥–µ–Ω–∏—Ö –ø–æ—Ä—É—à–µ–Ω—å. –¢–∞–∫–∏–º —á–∏–Ω–æ–º, –ø–æ–∫–∞–∑–Ω–∏–∫–∏ –∑ –∫—Ä–∏—Ç–∏—á–Ω–∏–º–∏ –≤—ñ–¥—Ö–∏–ª–µ–Ω–Ω—è–º–∏ –º–æ–∂—É—Ç—å –º–∞—Ç–∏ —è–∫—ñ—Å—Ç—å –Ω–∞–≤—ñ—Ç—å 0, —â–æ –¥–æ–∑–≤–æ–ª—è—î —Å–∏—Å—Ç–µ–º—ñ —É –ø–æ–¥–∞–ª—å—à–æ–º—É –≤—ñ–¥—Ñ—ñ–ª—å—Ç—Ä–æ–≤—É–≤–∞—Ç–∏ —Ç–∞–∫—ñ –¥–∞–Ω—ñ –ø—ñ–¥ —á–∞—Å –∞–Ω–∞–ª—ñ—Ç–∏–∫–∏.

 
–†–∏—Å—É–Ω–æ–∫ 3.1 ‚Äì UML ‚Äì –¥—ñ–∞–≥—Ä–∞–º–∞ –¥—ñ—è–ª—å–Ω–æ—Å—Ç—ñ –¥–ª—è –ª–æ–≥—ñ–∫–∏ –æ–±—Ä–æ–±–∫–∏ –ø–æ–∫–∞–∑–Ω–∏–∫—ñ–≤

–ü—ñ—Å–ª—è –≤–∏–∑–Ω–∞—á–µ–Ω–Ω—è —è–∫–æ—Å—Ç—ñ –¥–∞–Ω–∏—Ö —Å–µ—Ä–≤–µ—Ä —Å—Ç–≤–æ—Ä—é—î –∑–∞–ø–∏—Å —É –±–∞–∑—ñ –¥–∞–Ω–∏—Ö, –¥–µ –∑–±–µ—Ä—ñ–≥–∞—î –∑–Ω–∞—á–µ–Ω–Ω—è —Å–µ–Ω—Å–æ—Ä–∞, –æ–¥–∏–Ω–∏—Ü—é –≤–∏–º—ñ—Ä—é–≤–∞–Ω–Ω—è, —á–∞—Å–æ–≤—É –ø–æ–∑–Ω–∞—á–∫—É —Ç–∞ –æ–±—á–∏—Å–ª–µ–Ω–∏–π —Ä—ñ–≤–µ–Ω—å —è–∫–æ—Å—Ç—ñ. –ù–∞ –¥—ñ–∞–≥—Ä–∞–º—ñ –¥—ñ—è–ª—å–Ω–æ—Å—Ç—ñ (—Ä–∏—Å—É–Ω–æ–∫ 3.1) —Ü–µ–π –µ—Ç–∞–ø –≤—ñ–¥–ø–æ–≤—ñ–¥–∞—î –±–ª–æ–∫—É ¬´–ó–∞–ø–∏—Å –ø–æ–∫–∞–∑–Ω–∏–∫—ñ–≤ –¥–æ –ë–î¬ª. –†–∞–∑–æ–º —ñ–∑ –∑–∞–ø–∏—Å–æ–º —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—è –∑–±–∞–≥–∞—á—É—î—Ç—å—Å—è –¥–∞–Ω–∏–º–∏ –ø—Ä–æ —Å–µ–Ω—Å–æ—Ä —Ç–∞ —Å—Ç–∞–Ω—Ü—ñ—é.
–Ø–∫—â–æ –∂ –ø—ñ–¥ —á–∞—Å –æ–±—Ä–æ–±–∫–∏ –±—É–ª–æ –≤–∏—è–≤–ª–µ–Ω–æ –ø–æ—Ä—É—à–µ–Ω–Ω—è –ø–æ—Ä–æ–≥—ñ–≤, —Å–∏—Å—Ç–µ–º–∞ —ñ–Ω—ñ—Ü—ñ—é—î —Å—Ç–≤–æ—Ä–µ–Ω–Ω—è –≤—ñ–¥–ø–æ–≤—ñ–¥–Ω–∏—Ö —Å–ø–æ–≤—ñ—â–µ–Ω—å. –î–ª—è —Ü—å–æ–≥–æ –∑–∞–¥—ñ—é—î—Ç—å—Å—è –æ–∫—Ä–µ–º–∏–π —Å–µ—Ä–≤—ñ—Å, —è–∫–∏–π –≤–∏–∑–Ω–∞—á–∞—î, —á–∏ —ñ—Å–Ω—É—î –≤–∂–µ –∞–∫—Ç–∏–≤–Ω–µ —Å–ø–æ–≤—ñ—â–µ–Ω–Ω—è –ø–æ —Ü—å–æ–º—É —Å–µ–Ω—Å–æ—Ä—É, —á–∏ –ø–æ—Ç—Ä—ñ–±–Ω–æ —Å—Ç–≤–æ—Ä–∏—Ç–∏ –Ω–æ–≤–µ, –∞–±–æ –∂ –æ–Ω–æ–≤–∏—Ç–∏ –Ω–∞—è–≤–Ω–µ. –¢–∞–∫–∏–π –ø—ñ–¥—Ö—ñ–¥ –¥–æ–∑–≤–æ–ª—è—î —É–Ω–∏–∫–Ω—É—Ç–∏ –¥—É–±–ª—é–≤–∞–Ω–Ω—è –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω—å —ñ —Ä–µ–∞–ª—ñ–∑—É—î –ª–æ–≥—ñ–∫—É, –∑–æ–±—Ä–∞–∂–µ–Ω—É —É –≥—ñ–ª—Ü—ñ ¬´–ì–µ–Ω–µ—Ä–∞—Ü—ñ—è –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è –¥–ª—è —Å–ø–æ–≤—ñ—â–µ–Ω–Ω—è¬ª –Ω–∞ —Ä–∏—Å—É–Ω–∫—É 3.1.
–ó–∞–≤–µ—Ä—à–∞–ª—å–Ω–∏–º –µ—Ç–∞–ø–æ–º –º–µ—Ç–æ–¥ —Ñ–æ—Ä–º—É—î –≤—ñ–¥–ø–æ–≤—ñ–¥—å –∫–ª—ñ—î–Ω—Ç—É, –¥–µ –º—ñ—Å—Ç–∏—Ç—å—Å—è –¥–µ—Ç–∞–ª—å–Ω–∞ —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—è –ø—Ä–æ —â–æ–π–Ω–æ —Å—Ç–≤–æ—Ä–µ–Ω–∏–π –ø–æ–∫–∞–∑–Ω–∏–∫, –∞ —Ç–∞–∫–æ–∂ –ø–µ—Ä–µ–ª—ñ–∫ –ø–æ—Ä—É—à–µ–Ω–∏—Ö –ø–æ—Ä–æ–≥—ñ–≤, —è–∫—â–æ —Ç–∞–∫—ñ –±—É–ª–∏. –î–æ–¥–∞—Ç–∫–æ–≤–æ —Å–∏—Å—Ç–µ–º–∞ –ª–æ–≥—É–≤–∞–Ω–Ω—è —Ñ—ñ–∫—Å—É—î —É—Å–ø—ñ—à–Ω–µ —Å—Ç–≤–æ—Ä–µ–Ω–Ω—è –≤–∏–º—ñ—Ä—é–≤–∞–Ω–Ω—è –∞–±–æ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è –ø—Ä–æ –ø–æ–º–∏–ª–∫—É, —â–æ –∑–Ω–∞—á–Ω–æ —Å–ø—Ä–æ—â—É—î –Ω–∞–ª–∞–≥–æ–¥–∂–µ–Ω–Ω—è —Ç–∞ –º–æ–Ω—ñ—Ç–æ—Ä–∏–Ω–≥ —Ä–æ–±–æ—Ç–∏ —Å–µ—Ä–≤–µ—Ä–∞.
–ü–æ–≤–Ω–∏–π –∫–æ–¥ —Å–µ—Ä–≤—ñ—Å—É –Ω–∞–≤–µ–¥–µ–Ω–æ –≤ –¥–æ–¥–∞—Ç–∫—É –ê.
 
–†–∏—Å—É–Ω–æ–∫ 3.2 ‚Äì UML ‚Äì –¥—ñ–∞–≥—Ä–∞–º–∞ –≤–∑–∞—î–º–æ–¥—ñ—ó
	
–ù–∞ UML-–¥—ñ–∞–≥—Ä–∞–º—ñ –≤–∑–∞—î–º–æ–¥—ñ—ó (—Ä–∏—Å—É–Ω–æ–∫ 3.1) –≤—ñ–¥–æ–±—Ä–∞–∂–µ–Ω–æ –ø–æ–≤–Ω–∏–π –ª–∞–Ω—Ü—é–∂–æ–∫ –æ–±—Ä–æ–±–∫–∏ –≤–∏–º—ñ—Ä—é–≤–∞–Ω—å: –≤—ñ–¥ –Ω–∞–¥—Ö–æ–¥–∂–µ–Ω–Ω—è –¥–∞–Ω–∏—Ö –Ω–∞ —Å–µ—Ä–≤–µ—Ä –¥–æ —ó—Ö –ø–µ—Ä–µ—Ç–≤–æ—Ä–µ–Ω–Ω—è, –≤–∏–∑–Ω–∞—á–µ–Ω–Ω—è —è–∫–æ—Å—Ç—ñ —Ç–∞ –∑–±–µ—Ä–µ–∂–µ–Ω–Ω—è. –ü—ñ—Å–ª—è –æ—Ü—ñ–Ω–∫–∏ —è–∫–æ—Å—Ç—ñ –¥–∞–Ω–∏—Ö —Å–µ—Ä–≤–µ—Ä —Ñ–æ—Ä–º—É—î –∑–∞–ø–∏—Å —É –±–∞–∑—ñ –¥–∞–Ω–∏—Ö —ñ–∑ —Ñ–∞–∫—Ç–∏—á–Ω–∏–º –∑–Ω–∞—á–µ–Ω–Ω—è–º —Å–µ–Ω—Å–æ—Ä–∞, –æ–¥–∏–Ω–∏—Ü–µ—é –≤–∏–º—ñ—Ä—é–≤–∞–Ω–Ω—è, —á–∞—Å–æ–≤–æ—é –ø–æ–∑–Ω–∞—á–∫–æ—é —Ç–∞ —Ä—ñ–≤–Ω–µ–º —è–∫–æ—Å—Ç—ñ. –¶–µ–π –ø—Ä–æ—Ü–µ—Å –ø–æ–∑–Ω–∞—á–µ–Ω–∏–π –Ω–∞ –¥—ñ–∞–≥—Ä–∞–º—ñ —è–∫ ¬´–ó–∞–ø–∏—Å –¥–∞–Ω–∏—Ö –¥–æ –ë–î¬ª —ñ —Å—É–ø—Ä–æ–≤–æ–¥–∂—É—î—Ç—å—Å—è –∑–±–∞–≥–∞—á–µ–Ω–Ω—è–º —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—ó –º–µ—Ç–∞–¥–∞–Ω–∏–º–∏ —Å–µ–Ω—Å–æ—Ä–∞ —Ç–∞ —Å—Ç–∞–Ω—Ü—ñ—ó. –Ø–∫—â–æ –ø—ñ–¥ —á–∞—Å –æ–±—Ä–æ–±–∫–∏ –∑–∞—Ñ—ñ–∫—Å–æ–≤–∞–Ω–æ –ø–æ—Ä—É—à–µ–Ω–Ω—è –ø–æ—Ä–æ–≥–æ–≤–∏—Ö –∑–Ω–∞—á–µ–Ω—å, –∞–∫—Ç–∏–≤—É—î—Ç—å—Å—è –¥–æ–ø–æ–º—ñ–∂–Ω–∏–π —Å–µ—Ä–≤—ñ—Å —Å–ø–æ–≤—ñ—â–µ–Ω—å, —è–∫–∏–π –≤–∏–∑–Ω–∞—á–∞—î –Ω–µ–æ–±—Ö—ñ–¥–Ω—ñ—Å—Ç—å —Å—Ç–≤–æ—Ä–µ–Ω–Ω—è –Ω–æ–≤–æ–≥–æ –∞–±–æ –æ–Ω–æ–≤–ª–µ–Ω–Ω—è –Ω–∞—è–≤–Ω–æ–≥–æ —Å–ø–æ–≤—ñ—â–µ–Ω–Ω—è, —â–æ –∑–æ–±—Ä–∞–∂–µ–Ω–æ —É –≥—ñ–ª—Ü—ñ 5. 

3.2.1.2 –†–æ–∑—Ä–∞—Ö—É–≤–∞–Ω–Ω—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –ø–æ –º–æ–Ω—ñ—Ç–æ—Ä–∏–Ω–≥–æ–≤—ñ–π —Å—Ç–∞–Ω—Ü—ñ—ó

–ü—Ä–æ—Ü–µ—Å —Ñ–æ—Ä–º—É–≤–∞–Ω–Ω—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –º–æ–Ω—ñ—Ç–æ—Ä–∏–Ω–≥–æ–≤–æ—ó —Å—Ç–∞–Ω—Ü—ñ—ó —Ä–µ–∞–ª—ñ–∑–æ–≤–∞–Ω–æ –≤ —Å–µ—Ä–≤–µ—Ä–Ω—ñ–π —á–∞—Å—Ç–∏–Ω—ñ –ø—Ä–æ–≥—Ä–∞–º–Ω–æ—ó —Å–∏—Å—Ç–µ–º–∏ —É –≤–∏–≥–ª—è–¥—ñ –º–µ—Ç–æ–¥—É getStationStats(). –î–∞–Ω–∏–π –º–µ—Ç–æ–¥ –≤—ñ–¥–ø–æ–≤—ñ–¥–∞—î –∑–∞ –æ–±‚Äô—î–¥–Ω–∞–Ω–Ω—è –¥–∞–Ω–∏—Ö –∑ —Ä—ñ–∑–Ω–∏—Ö —Å—É—Ç–Ω–æ—Å—Ç–µ–π –±–∞–∑–∏ –¥–∞–Ω–∏—Ö, —ó—Ö –Ω–æ—Ä–º–∞–ª—ñ–∑–∞—Ü—ñ—é, –ø–µ—Ä–µ—Ç–≤–æ—Ä–µ–Ω–Ω—è –æ–¥–∏–Ω–∏—Ü—å –≤–∏–º—ñ—Ä—é–≤–∞–Ω–Ω—è, —Ñ—ñ–ª—å—Ç—Ä–∞—Ü—ñ—é —Ç–∞ –∞–Ω–∞–ª—ñ—Ç–∏—á–Ω—É –æ–±—Ä–æ–±–∫—É. –ó–∞–≥–∞–ª—å–Ω–∞ –ø–æ—Å–ª—ñ–¥–æ–≤–Ω—ñ—Å—Ç—å –≤–∏–∫–æ–Ω–∞–Ω–Ω—è –æ–ø–µ—Ä–∞—Ü—ñ–π –≤—ñ–¥–æ–±—Ä–∞–∂–µ–Ω–∞ –Ω–∞ UML-–¥—ñ–∞–≥—Ä–∞–º—ñ –¥—ñ—è–ª—å–Ω–æ—Å—Ç—ñ (—Ä–∏—Å—É–Ω–æ–∫ 3.3), –∞ –ø–æ–≤–Ω–∏–π –ø—Ä–æ–≥—Ä–∞–º–Ω–∏–π –∫–æ–¥ —Å–µ—Ä–≤—ñ—Å—É –Ω–∞–≤–µ–¥–µ–Ω–æ –≤ –¥–æ–¥–∞—Ç–∫—É –ë.
–ù–∞ –ø–µ—Ä—à–æ–º—É –µ—Ç–∞–ø—ñ –º–µ—Ç–æ–¥ –æ—Ç—Ä–∏–º—É—î –Ω–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞, –∑–æ–∫—Ä–µ–º–∞ –≤–∏–±—Ä–∞–Ω—É —Å–∏—Å—Ç–µ–º—É –æ–¥–∏–Ω–∏—Ü—å –≤–∏–º—ñ—Ä—é–≤–∞–Ω–Ω—è (metric –∞–±–æ imperial). –¶–µ –≤–∏–∑–Ω–∞—á–∞—î, —É —è–∫—ñ–π —Å–∏—Å—Ç–µ–º—ñ –±—É–¥—É—Ç—å –ø–æ–≤–µ—Ä–Ω—É—Ç—ñ –∑–Ω–∞—á–µ–Ω–Ω—è —Å–µ–Ω—Å–æ—Ä—ñ–≤. –í–Ω—É—Ç—Ä—ñ—à–Ω—î –∑–±–µ—Ä—ñ–≥–∞–Ω–Ω—è –¥–∞–Ω–∏—Ö –∑–¥—ñ–π—Å–Ω—é—î—Ç—å—Å—è —É —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ñ–π —Å–∏—Å—Ç–µ–º—ñ (storageUnitSystem), —Ç–æ–º—É –ø–µ—Ä–µ–¥ —Ñ–æ—Ä–º—É–≤–∞–Ω–Ω—è–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç—É –≤–∏–∫–æ–Ω—É—î—Ç—å—Å—è –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü—ñ—è –∑–Ω–∞—á–µ–Ω—å –∑–∞ –¥–æ–ø–æ–º–æ–≥–æ—é —Å–µ—Ä–≤—ñ—Å—É unitConversion.
–î–∞–ª—ñ –∑ –±–∞–∑–∏ –¥–∞–Ω–∏—Ö –∑–∞–≤–∞–Ω—Ç–∞–∂—É—é—Ç—å—Å—è –≤—Å—ñ –ø–æ–≤‚Äô—è–∑–∞–Ω—ñ –∑ –º–æ–Ω—ñ—Ç–æ—Ä–∏–Ω–≥–æ–≤–æ—é —Å—Ç–∞–Ω—Ü—ñ—î—é —Å—É—Ç–Ω–æ—Å—Ç—ñ: –∞–∫—Ç–∏–≤–Ω—ñ —Å–µ–Ω—Å–æ—Ä–∏ —Ä–∞–∑–æ–º –∑ –æ—Å—Ç–∞–Ω–Ω—ñ–º–∏ –≤–∏–º—ñ—Ä—é–≤–∞–Ω–Ω—è–º–∏ —Ç–∞ —Å—Ç–∞—Ç—É—Å–∞–º–∏, –∞–≥—Ä–µ–≥–æ–≤–∞–Ω—ñ —Å—Ç–∞—Ç–∏—Å—Ç–∏—á–Ω—ñ –¥–∞–Ω—ñ –∑–∞ –æ—Å—Ç–∞–Ω–Ω—ñ 24 –≥–æ–¥–∏–Ω–∏, –∞–∫—Ç–∏–≤–Ω—ñ —Å–ø–æ–≤—ñ—â–µ–Ω–Ω—è –∑–∞ –æ—Å—Ç–∞–Ω–Ω—ñ 7 –¥—ñ–±, –∞ —Ç–∞–∫–æ–∂ –∑–∞–ø–ª–∞–Ω–æ–≤–∞–Ω—ñ —Ä–æ–±–æ—Ç–∏ –∑ —Ç–µ—Ö–Ω—ñ—á–Ω–æ–≥–æ –æ–±—Å–ª—É–≥–æ–≤—É–≤–∞–Ω–Ω—è. –Ø–∫—â–æ —Å—Ç–∞–Ω—Ü—ñ—è –∑ –≤–∫–∞–∑–∞–Ω–∏–º —ñ–¥–µ–Ω—Ç–∏—Ñ—ñ–∫–∞—Ç–æ—Ä–æ–º –Ω–µ —ñ—Å–Ω—É—î, –ø–æ–≤–µ—Ä—Ç–∞—î—Ç—å—Å—è –ø–æ–º–∏–ª–∫–∞ NotFoundException.

 
–†–∏—Å—É–Ω–æ–∫ 3.3 ‚Äì UML-–¥—ñ–∞–≥—Ä–∞–º–∞ –¥—ñ—è–ª—å–Ω–æ—Å—Ç—ñ –¥–ª—è –ª–æ–≥—ñ–∫–∏ –ø—ñ–¥—Ä–∞—Ö—É–≤–∞–Ω–Ω—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –ø–æ —Å—Ç–∞–Ω—Ü—ñ—ó

–û–±—Ä–æ–±–∫–∞ —Å–µ–Ω—Å–æ—Ä—ñ–≤ –≤–∫–ª—é—á–∞—î –≤–∏–±—ñ—Ä –æ—Å—Ç–∞–Ω–Ω—å–æ–≥–æ –∑–∞–ø–∏—Å—É –≤–∏–º—ñ—Ä—é–≤–∞–Ω–Ω—è (lastReading) —Ç–∞ –æ—Å—Ç–∞–Ω–Ω—å–æ–≥–æ —Å—Ç–∞—Ç—É—Å—É —Ä–æ–±–æ—Ç–∏ —Å–µ–Ω—Å–æ—Ä–∞ (statusHistory). –Ø–∫—â–æ –¥–æ—Å—Ç—É–ø–Ω–µ –∞–∫—Ç—É–∞–ª—å–Ω–µ –≤–∏–º—ñ—Ä—é–≤–∞–Ω–Ω—è, –≤–æ–Ω–æ –∫–æ–Ω–≤–µ—Ä—Ç—É—î—Ç—å—Å—è —É —Å–∏—Å—Ç–µ–º—É –æ–¥–∏–Ω–∏—Ü—å –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞:
const converted = this.unitConversion.convertValue(
    lastReading.value,
    sensor.type,
    { fromUnit: storageUnitSystem, toUnit: userUnitSystem }
);
	–£ —Ç–∞–∫–∏–π —Å–ø–æ—Å—ñ–± –∑–∞–±–µ–∑–ø–µ—á—É—î—Ç—å—Å—è —É–∑–≥–æ–¥–∂–µ–Ω—ñ—Å—Ç—å –¥–∞–Ω–∏—Ö –Ω–µ–∑–∞–ª–µ–∂–Ω–æ –≤—ñ–¥ —Ç–æ–≥–æ, —É —è–∫—ñ–π —Å–∏—Å—Ç–µ–º—ñ –≤–æ–Ω–∏ –∑–±–µ—Ä—ñ–≥–∞—é—Ç—å—Å—è —É –≤–Ω—É—Ç—Ä—ñ—à–Ω—å–æ–º—É —Å—Ö–æ–≤–∏—â—ñ. –¢–∞–∫–æ–∂ —Ñ–æ—Ä–º—É—î—Ç—å—Å—è –æ–±‚Äô—î–∫—Ç —Å—Ç–∞—Ç—É—Å—É —Å–µ–Ω—Å–æ—Ä–∞: —Ä—ñ–≤–µ–Ω—å –∑–∞—Ä—è–¥—É, —Å–∏–≥–Ω–∞–ª, —á–∞—Å –æ—Å—Ç–∞–Ω–Ω—å–æ—ó –ø–µ—Ä–µ–≤—ñ—Ä–∫–∏.
–ü–æ–¥—ñ–±–Ω–∞ –ª–æ–≥—ñ–∫–∞ –∑–∞—Å—Ç–æ—Å–æ–≤—É—î—Ç—å—Å—è –¥–æ –∞–≥—Ä–µ–≥–æ–≤–∞–Ω–∏—Ö —Å—Ç–∞—Ç–∏—Å—Ç–∏—á–Ω–∏—Ö –∑–Ω–∞—á–µ–Ω—å. –î–ª—è –∫–æ–∂–Ω–æ–≥–æ –∑–∞–ø–∏—Å—É –≤–∏–∫–æ–Ω—É—î—Ç—å—Å—è –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü—ñ—è —Å–µ—Ä–µ–¥–Ω—å–æ–≥–æ, –º—ñ–Ω—ñ–º–∞–ª—å–Ω–æ–≥–æ —Ç–∞ –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–≥–æ –∑–Ω–∞—á–µ–Ω–Ω—è:
const convertedAvg = this.unitConversion.convertValue(agg.average, agg.sensorType, ...);
const convertedMin = this.unitConversion.convertValue(agg.minValue, agg.sensorType, ...);
const convertedMax = this.unitConversion.convertValue(agg.maxValue, agg.sensorType, ...);
–¢–∞–∫–∏–º —á–∏–Ω–æ–º —Ñ–æ—Ä–º—É—î—Ç—å—Å—è —Å—Ç–∞–Ω–¥–∞—Ä—Ç–∏–∑–æ–≤–∞–Ω–∏–π –±–ª–æ–∫ –¥–∞–Ω–∏—Ö, —â–æ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î—Ç—å—Å—è —É –≥—Ä–∞—Ñ—ñ—á–Ω—ñ–π –∞–Ω–∞–ª—ñ—Ç–∏—Ü—ñ –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞.
–î–∞–Ω—ñ –∞–∫—Ç–∏–≤–Ω–∏—Ö —Å–ø–æ–≤—ñ—â–µ–Ω—å —Ç–∞–∫–æ–∂ –ø—ñ–¥–ª—è–≥–∞—é—Ç—å –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü—ñ—ó. –î–ª—è –∫–æ–∂–Ω–æ–≥–æ –ø–æ–ø–µ—Ä–µ–¥–∂–µ–Ω–Ω—è –Ω–æ—Ä–º–∞–ª—ñ–∑—É—é—Ç—å—Å—è –∑–Ω–∞—á–µ–Ω–Ω—è —Ñ–∞–∫—Ç–∏—á–Ω–æ–≥–æ –≤–∏–º—ñ—Ä—é–≤–∞–Ω–Ω—è —Ç–∞ –ø–æ—Ä–æ–≥–æ–≤–æ–≥–æ –∑–Ω–∞—á–µ–Ω–Ω—è, —â–æ –¥–æ–∑–≤–æ–ª—è—î –∫–æ—Ä–µ–∫—Ç–Ω–æ –∑—ñ—Å—Ç–∞–≤–ª—è—Ç–∏ —Å–ø–æ—Å—Ç–µ—Ä–µ–∂—É–≤–∞–Ω—É –≤–µ–ª–∏—á–∏–Ω—É –∑ —ó—ó –∫—Ä–∏—Ç–∏—á–Ω–∏–º –ø–æ—Ä–æ–≥–æ–º.
–û–∫—Ä–µ–º–∏–º –µ—Ç–∞–ø–æ–º —Ñ–æ—Ä–º—É—î—Ç—å—Å—è –ø–µ—Ä–µ–ª—ñ–∫ –º–∞–π–±—É—Ç–Ω—ñ—Ö —Ä–æ–±—ñ—Ç –∑ —Ç–µ—Ö–Ω—ñ—á–Ω–æ–≥–æ –æ–±—Å–ª—É–≥–æ–≤—É–≤–∞–Ω–Ω—è, –¥–µ –¥–ª—è –∫–æ–∂–Ω–æ–≥–æ –∑–∞–ø–∏—Å—É –∑–±–µ—Ä—ñ–≥–∞—é—Ç—å—Å—è –æ—Å–Ω–æ–≤–Ω—ñ –∞—Ç—Ä–∏–±—É—Ç–∏ ‚Äî –Ω–∞–∑–≤–∞, –æ–ø–∏—Å, —Ç–∏–ø, –¥–∞—Ç–∞ –ø–æ—á–∞—Ç–∫—É —Ç–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–Ω—è.
–ü—ñ—Å–ª—è –æ–±—Ä–æ–±–∫–∏ –≤—Å—ñ—Ö –¥–∞–Ω–∏—Ö –º–µ—Ç–æ–¥ –≤–∏–∫–æ–Ω—É—î –æ–±—á–∏—Å–ª–µ–Ω–Ω—è –ø—ñ–¥—Å—É–º–∫–æ–≤–∏—Ö –ø–æ–∫–∞–∑–Ω–∏–∫—ñ–≤ —Å—Ç–∞–Ω—Ü—ñ—ó. –î–æ —Ç–∞–∫–∏—Ö –ø–æ–∫–∞–∑–Ω–∏–∫—ñ–≤ –Ω–∞–ª–µ–∂–∞—Ç—å:
ÔÄ≠	–∑–∞–≥–∞–ª—å–Ω–∞ –∫—ñ–ª—å–∫—ñ—Å—Ç—å —Å–µ–Ω—Å–æ—Ä—ñ–≤;
ÔÄ≠	–∫—ñ–ª—å–∫—ñ—Å—Ç—å –∞–∫—Ç–∏–≤–Ω–∏—Ö —Å–µ–Ω—Å–æ—Ä—ñ–≤;
ÔÄ≠	–∫—ñ–ª—å–∫—ñ—Å—Ç—å —Å–µ–Ω—Å–æ—Ä—ñ–≤, —è–∫—ñ –ø–µ—Ä–µ–±—É–≤–∞—é—Ç—å –æ–Ω–ª–∞–π–Ω;
ÔÄ≠	–∫—ñ–ª—å–∫—ñ—Å—Ç—å –∞–∫—Ç–∏–≤–Ω–∏—Ö –ø–æ–ø–µ—Ä–µ–¥–∂–µ–Ω—å;
ÔÄ≠	–∫—ñ–ª—å–∫—ñ—Å—Ç—å –∫—Ä–∏—Ç–∏—á–Ω–∏—Ö –ø–æ–ø–µ—Ä–µ–¥–∂–µ–Ω—å;
ÔÄ≠	–∫—ñ–ª—å–∫—ñ—Å—Ç—å –∑–∞–ø–ª–∞–Ω–æ–≤–∞–Ω–∏—Ö —Ä–æ–±—ñ—Ç –∑ —Ç–µ—Ö–Ω—ñ—á–Ω–æ–≥–æ –æ–±—Å–ª—É–≥–æ–≤—É–≤–∞–Ω–Ω—è.
–ü—Ä–∏–∫–ª–∞–¥–∏ –≤—ñ–¥–ø–æ–≤—ñ–¥–Ω–∏—Ö –æ–±—á–∏—Å–ª–µ–Ω—å:
const onlineSensors = processedSensors.filter(s => s.status?.isOnline).length;
const activeAlerts = processedAlerts.filter(a => a.isActive).length;
const criticalAlerts = processedAlerts.filter(a =>
    a.isActive && a.severity === AlertSeverity.CRITICAL
).length;
–¢–∞–∫–∏–º —á–∏–Ω–æ–º —Ñ–æ—Ä–º—É—î—Ç—å—Å—è –ø–æ–≤–Ω–∏–π –æ–≥–ª—è–¥ –ø–æ—Ç–æ—á–Ω–æ–≥–æ —Å—Ç–∞–Ω—É –º–æ–Ω—ñ—Ç–æ—Ä–∏–Ω–≥–æ–≤–æ—ó —Å—Ç–∞–Ω—Ü—ñ—ó.
–ö—Ä—ñ–º –∑–∞–≥–∞–ª—å–Ω–æ—ó —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ —Å–∏—Å—Ç–µ–º–∞ —Ç–∞–∫–æ–∂ –∑–∞–±–µ–∑–ø–µ—á—É—î –º–æ–∂–ª–∏–≤—ñ—Å—Ç—å –≥–µ–Ω–µ—Ä–∞—Ü—ñ—ó –¥–µ—Ç–∞–ª—ñ–∑–æ–≤–∞–Ω–∏—Ö –ø–æ–∫–∞–∑–Ω–∏–∫—ñ–≤ –¥–ª—è –ø–µ–≤–Ω–æ–≥–æ —Ç–∏–ø—É —Å–µ–Ω—Å–æ—Ä—ñ–≤ (getSensorTypeStats). –£ —Ü—å–æ–º—É –≤–∏–ø–∞–¥–∫—É –æ–±—Ä–æ–±–ª—è—é—Ç—å—Å—è –∞–≥—Ä–µ–≥–æ–≤–∞–Ω—ñ –¥–∞–Ω—ñ –∑–∞ –æ—Å—Ç–∞–Ω–Ω—ñ —Å—ñ–º –¥–Ω—ñ–≤, –∫–æ–Ω–≤–µ—Ä—Ç—É—é—Ç—å—Å—è —É –ø–æ—Ç—Ä—ñ–±–Ω—É —Å–∏—Å—Ç–µ–º—É –æ–¥–∏–Ω–∏—Ü—å —ñ –ø–æ–≤–µ—Ä—Ç–∞—é—Ç—å—Å—è —É –≤–∏–≥–ª—è–¥—ñ —á–∞—Å–æ–≤–∏—Ö —Ä—è–¥—ñ–≤ –¥–ª—è –ø–æ–±—É–¥–æ–≤–∏ –≥—Ä–∞—Ñ—ñ–∫—ñ–≤.
–û–∫—Ä–µ–º–æ –±—É–ª–æ —Ä–µ–∞–ª—ñ–∑–æ–≤–∞–Ω–æ —Ñ—É–Ω–∫—Ü—ñ—é –æ—Ü—ñ–Ω–∫–∏ –∑–∞–≥–∞–ª—å–Ω–æ–≥–æ —Å—Ç–∞–Ω—É —Å—Ç–∞–Ω—Ü—ñ—ó (getStationHealth). –í–æ–Ω–∞ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î –±–∞–ª—å–Ω—É —Å–∏—Å—Ç–µ–º—É (0‚Äì100), —É —è–∫—ñ–π –≤—Ä–∞—Ö–æ–≤—É—é—Ç—å—Å—è –¥–≤–∞ —Ç–∏–ø–∏ —à—Ç—Ä–∞—Ñ—ñ–≤:
1)	–®—Ç—Ä–∞—Ñ –∑–∞ –≤—ñ–¥–∫–ª—é—á–µ–Ω—ñ —Å–µ–Ω—Å–æ—Ä–∏:
–§–æ—Ä–º—É–ª–∞: 
–®—Ç—Ä–∞—Ñ=((–∫—ñ–ª—å–∫—ñ—Å—Ç—å —Å–µ–Ω—Å–æ—Ä—ñ–≤ / —Å–µ–Ω—Å–æ—Ä–∏ –æ–Ω–ª–∞–π–Ω) /
(–∑–∞–≥–∞–ª—å–Ω–∞ –∫—ñ–ª—å–∫—ñ—Å—Ç—å —Å–µ–Ω—Å–æ—Ä—ñ–≤) * 40
2)	–®—Ç—Ä–∞—Ñ –∑–∞ –∞–∫—Ç–∏–≤–Ω—ñ —Å–ø–æ–≤—ñ—â–µ–Ω–Ω—è:
–§–æ—Ä–º—É–ª–∞: 
–®—Ç—Ä–∞—Ñ=(min (–∞–∫—Ç–∏–≤–Ω—ñ —Å–ø–æ–≤—ñ—â–µ–Ω–Ω—è) * 10.3)
–§—ñ–Ω–∞–ª—å–Ω–∏–π –ø–æ–∫–∞–∑–Ω–∏–∫ –≤–∏–∑–Ω–∞—á–∞—î—Ç—å—Å—è —è–∫:
Health = max(0, 100 ‚Äì —à—Ç—Ä–∞—Ñ 1 ‚Äì —à—Ç—Ä–∞—Ñ 2)
–ù–∞–ø—Ä–∏–∫–ª–∞–¥, –ø—Ä–∏ 10 —Å–µ–Ω—Å–æ—Ä–∞—Ö, –∑ —è–∫–∏—Ö 8 –æ–Ω–ª–∞–π–Ω, —Ç–∞ –¥–≤–æ—Ö –∞–∫—Ç–∏–≤–Ω–∏—Ö –ø–æ–ø–µ—Ä–µ–¥–∂–µ–Ω–Ω—è—Ö –±—É–¥–µ:
offlinePenalty = (2/10) √ó 40 = 8
alertPenalty = 2 √ó 10 = 20
healthScore = 100 ‚àí 8 ‚àí 20 = 72 ‚Üí —Å—Ç–∞—Ç—É—Å FAIR
–¶–µ–π –ø—ñ–¥—Ö—ñ–¥ –¥–æ–∑–≤–æ–ª—è—î –∫—ñ–ª—å–∫—ñ—Å–Ω–æ –æ—Ü—ñ–Ω–∏—Ç–∏ —Å—Ç–∞–Ω —Å—Ç–∞–Ω—Ü—ñ—ó —Ç–∞ –ø–æ—Ä—ñ–≤–Ω—é–≤–∞—Ç–∏ –π–æ–≥–æ –º—ñ–∂ —Ä—ñ–∑–Ω–∏–º–∏ –æ–±‚Äô—î–∫—Ç–∞–º–∏.

3.2.1.3 –ü–µ—Ä–µ–≤–µ–¥–µ–Ω–Ω—è –º—ñ–∂ —Å–∏—Å—Ç–µ–º–∞–º–∏ –≤–∏–º—ñ—Ä—é–≤–∞–Ω–Ω—è 

–£ –ø—Ä–æ—Ü–µ—Å—ñ —Ä–æ–∑—Ä–∞—Ö—É–≤–∞–Ω–Ω—è —Å—Ç–∞—Ç–∏—Å—Ç–∏—á–Ω–∏—Ö –ø–æ–∫–∞–∑–Ω–∏–∫—ñ–≤ –º–æ–Ω—ñ—Ç–æ—Ä–∏–Ω–≥–æ–≤–æ—ó —Å—Ç–∞–Ω—Ü—ñ—ó –≤–∏–Ω–∏–∫–∞—î –Ω–µ–æ–±—Ö—ñ–¥–Ω—ñ—Å—Ç—å –≤—ñ–¥–æ–±—Ä–∞–∂–∞—Ç–∏ –∑–Ω–∞—á–µ–Ω–Ω—è –≤–∏–º—ñ—Ä—é–≤–∞–Ω–∏—Ö –ø–∞—Ä–∞–º–µ—Ç—Ä—ñ–≤ —É —Ç—ñ–π —Å–∏—Å—Ç–µ–º—ñ –æ–¥–∏–Ω–∏—Ü—å, —è–∫—É –æ–±—Ä–∞–≤ –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á. –û—Å–∫—ñ–ª—å–∫–∏ –¥–∞–Ω—ñ –∑–±–µ—Ä—ñ–≥–∞—é—Ç—å—Å—è —É –±–∞–∑—ñ –¥–∞–Ω–∏—Ö —É —Å—Ç–∞–Ω–¥–∞—Ä—Ç–∏–∑–æ–≤–∞–Ω—ñ–π –≤–Ω—É—Ç—Ä—ñ—à–Ω—ñ–π —Å–∏—Å—Ç–µ–º—ñ (–∑–∞ –∑–∞–º–æ–≤—á—É–≤–∞–Ω–Ω—è–º ‚Äî –º–µ—Ç—Ä–∏—á–Ω—ñ–π), –±—ñ–∑–Ω–µ—Å-–ª–æ–≥—ñ–∫–∞ –ø–æ–≤–∏–Ω–Ω–∞ –¥–∏–Ω–∞–º—ñ—á–Ω–æ –∫–æ–Ω–≤–µ—Ä—Ç—É–≤–∞—Ç–∏ —ó—Ö —É –º–µ—Ç—Ä–∏—á–Ω—É –∞–±–æ —ñ–º–ø–µ—Ä—Å—å–∫—É —Å–∏—Å—Ç–µ–º—É –∑–∞–ª–µ–∂–Ω–æ –≤—ñ–¥ –Ω–∞–ª–∞—à—Ç—É–≤–∞–Ω—å –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞. –†–µ–∞–ª—ñ–∑–∞—Ü—ñ—è –≤—ñ–¥–ø–æ–≤—ñ–¥–Ω–æ–≥–æ –ø—Ä–æ–≥—Ä–∞–º–Ω–æ–≥–æ –º–æ–¥—É–ª—è –ø–æ–¥–∞–Ω–∞ –≤ —Å–µ—Ä–≤—ñ—Å—ñ UnitConversionService, –ø–æ–≤–Ω–∏–π –∫–æ–¥ —è–∫–æ–≥–æ –Ω–∞–≤–µ–¥–µ–Ω–æ –≤ –¥–æ–¥–∞—Ç–∫—É –í.
–û—Å–Ω–æ–≤–Ω–∏–π –º–µ—Ç–æ–¥ convertValue() –≤–∏–∫–æ–Ω—É—î –≤–∏–∑–Ω–∞—á–µ–Ω–Ω—è –Ω–∞–ø—Ä—è–º–∫—É –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü—ñ—ó –∑–∞–ª–µ–∂–Ω–æ –≤—ñ–¥ –ø–∞—Ä–∞–º–µ—Ç—Ä—ñ–≤ fromUnit —Ç–∞ toUnit. –Ø–∫—â–æ —Å–∏—Å—Ç–µ–º–∏ –æ–¥–∏–Ω–∏—Ü—å —Å–ø—ñ–≤–ø–∞–¥–∞—é—Ç—å, –∑–Ω–∞—á–µ–Ω–Ω—è –Ω–µ –∑–º—ñ–Ω—é—î—Ç—å—Å—è; —É —Ç–∞–∫–æ–º—É –≤–∏–ø–∞–¥–∫—É –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î—Ç—å—Å—è –º–µ—Ç–æ–¥ toMetric() –∞–±–æ toImperial(), —è–∫–∏–π –ª–∏—à–µ –ø—ñ–¥–±–∏—Ä–∞—î –∫–æ—Ä–µ–∫—Ç–Ω–µ –ø–æ–∑–Ω–∞—á–µ–Ω–Ω—è –æ–¥–∏–Ω–∏—Ü—å –¥–ª—è –≤—ñ–¥–ø–æ–≤—ñ–¥–Ω–æ–≥–æ —Ç–∏–ø—É —Å–µ–Ω—Å–æ—Ä–∞:
if (options.fromUnit === options.toUnit) {
    return options.fromUnit === 'metric'
        ? this.toMetric(value, sensorType)
        : this.toImperial(value, sensorType);
}
–£ —Ä–∞–∑—ñ —Ä—ñ–∑–Ω–∏—Ö —Å–∏—Å—Ç–µ–º –≤–∏–º—ñ—Ä—é–≤–∞–Ω–Ω—è –≤–∏–∫–æ–Ω—É—î—Ç—å—Å—è –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü—ñ—è –∑–≥—ñ–¥–Ω–æ –≤–∏–∑–Ω–∞—á–µ–Ω–∏—Ö —Ñ–æ—Ä–º—É–ª. –î–ª—è –∫–æ–∂–Ω–æ–≥–æ —Ç–∏–ø—É —Å–µ–Ω—Å–æ—Ä–∞ –∑–∞—Å—Ç–æ—Å–æ–≤—É—é—Ç—å—Å—è –≤—ñ–¥–ø–æ–≤—ñ–¥–Ω—ñ –∞–ª–≥–æ—Ä–∏—Ç–º–∏ –ø–µ—Ä–µ—Ç–≤–æ—Ä–µ–Ω–Ω—è, —â–æ –¥–æ–∑–≤–æ–ª—è—é—Ç—å –∞–¥–∞–ø—Ç—É–≤–∞—Ç–∏ –ø–æ–∫–∞–∑–Ω–∏–∫–∏ —Ç–µ–º–ø–µ—Ä–∞—Ç—É—Ä–∏, —Ç–∏—Å–∫—É —Ç–∞ —ñ–Ω—à–∏—Ö –ø–∞—Ä–∞–º–µ—Ç—Ä—ñ–≤. –ù–∞–ø—Ä–∏–∫–ª–∞–¥, –ø—ñ–¥ —á–∞—Å –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü—ñ—ó —Ç–µ–º–ø–µ—Ä–∞—Ç—É—Ä–∏ –∑ –º–µ—Ç—Ä–∏—á–Ω–æ—ó —Å–∏—Å—Ç–µ–º–∏ –≤ —ñ–º–ø–µ—Ä—Å—å–∫—É –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î—Ç—å—Å—è —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–∞ —Ñ–æ—Ä–º—É–ª–∞ –ø–µ—Ä–µ—Ö–æ–¥—É –≤—ñ–¥ –≥—Ä–∞–¥—É—Å—ñ–≤ –¶–µ–ª—å—Å—ñ—è –¥–æ –§–∞—Ä–µ–Ω–≥–µ–π—Ç–∞:
Tf = Tc * (9/5) + 32,
—â–æ –≤ –∫–æ–¥—ñ —Ä–µ–∞–ª—ñ–∑–æ–≤–∞–Ω–æ –Ω–∞—Å—Ç—É–ø–Ω–∏–º —á–∏–Ω–æ–º:
return { value: (value * 9/5) + 32, unit: '¬∞F' };
–ó–≤–æ—Ä–æ—Ç–Ω–µ –ø–µ—Ä–µ—Ç–≤–æ—Ä–µ–Ω–Ω—è ‚Äî –∑ –§–∞—Ä–µ–Ω–≥–µ–π—Ç–∞ —É –¶–µ–ª—å—Å—ñ–π ‚Äî –≤–∏–∫–æ–Ω—É—î—Ç—å—Å—è –∑–∞ —Ñ–æ—Ä–º—É–ª–æ—é:
Tc = (Tf - 32) * (5/9),
—è–∫–∞ –≤—ñ–¥–æ–±—Ä–∞–∂–µ–Ω–∞ –≤ –º–µ—Ç–æ–¥—ñ imperialToMetric():
return { value: (value - 32) * 5/9, unit: '¬∞C' };
–î–ª—è –±–∞—Ä–æ–º–µ—Ç—Ä–∏—á–Ω–æ–≥–æ —Ç–∏—Å–∫—É –≤–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–æ —Ñ—ñ–∑–∏—á–Ω—É –∑–∞–ª–µ–∂–Ω—ñ—Å—Ç—å –º—ñ–∂ –≥–µ–∫—Ç–∞–ø–∞—Å–∫–∞–ª—è–º–∏ (hPa) —Ç–∞ –¥—é–π–º–∞–º–∏ —Ä—Ç—É—Ç–Ω–æ–≥–æ —Å—Ç–æ–≤–ø—á–∏–∫–∞ (inHg). –ü–µ—Ä–µ—Ö—ñ–¥ –≤—ñ–¥ –º–µ—Ç—Ä–∏—á–Ω–æ—ó —Å–∏—Å—Ç–µ–º–∏ –¥–æ —ñ–º–ø–µ—Ä—Å—å–∫–æ—ó –∑–¥—ñ–π—Å–Ω—é—î—Ç—å—Å—è –∑–∞ —Ñ–æ—Ä–º—É–ª–æ—é:
ùëÉinHg=ùëÉhPa ‚ãÖ 0.02953,
—â–æ —Ä–µ–∞–ª—ñ–∑–æ–≤–∞–Ω–æ –Ω–∞—Å—Ç—É–ø–Ω–∏–º –∫–æ–¥–æ–º:
return { value: value * 0.02953, unit: 'inHg' };
–ó–≤–æ—Ä–æ—Ç–Ω–∞ —Ñ–æ—Ä–º—É–ª–∞:
ùëÉhPa=ùëÉinHg/0.02953, 
–ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∞ –≤ –º–µ—Ç–æ–¥—ñ –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü—ñ—ó imperialToMetric():
return { value: value / 0.02953, unit: 'hPa' };
	–í–∞–∂–ª–∏–≤–æ, —â–æ –¥–ª—è –±—ñ–ª—å—à–æ—Å—Ç—ñ –µ–∫–æ–ª–æ–≥—ñ—á–Ω–∏—Ö —Å–µ–Ω—Å–æ—Ä—ñ–≤, —Ç–∞–∫–∏—Ö —è–∫ PM2.5, PM10, —Ä—ñ–≤–µ–Ω—å —à—É–º—É, –≤–æ–ª–æ–≥—ñ—Å—Ç—å –∞–±–æ –∫–æ–Ω—Ü–µ–Ω—Ç—Ä–∞—Ü—ñ—è CO‚ÇÇ, –æ–¥–∏–Ω–∏—Ü—ñ –≤–∏–º—ñ—Ä—é–≤–∞–Ω–Ω—è –Ω–µ –∑–∞–ª–µ–∂–∞—Ç—å –≤—ñ–¥ –æ–±—Ä–∞–Ω–æ—ó —Å–∏—Å—Ç–µ–º–∏, —Ç–æ–º—É –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü—ñ—è –æ–±–º–µ–∂—É—î—Ç—å—Å—è –ª–∏—à–µ –ø–æ–≤–µ—Ä–Ω–µ–Ω–Ω—è–º –≤–∏—Ö—ñ–¥–Ω–æ–≥–æ –∑–Ω–∞—á–µ–Ω–Ω—è –∑ –≤—ñ–¥–ø–æ–≤—ñ–¥–Ω–æ—é –æ–¥–∏–Ω–∏—Ü–µ—é:
case SensorType.PM2_5:
case SensorType.PM10:
    return { value, unit: '¬µg/m¬≥' };
–¢–∞–∫–∏–º —á–∏–Ω–æ–º, —Å–µ—Ä–≤—ñ—Å –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü—ñ—ó –∑–∞–±–µ–∑–ø–µ—á—É—î —É–Ω—ñ—Ñ—ñ–∫–æ–≤–∞–Ω–∏–π –º–µ—Ö–∞–Ω—ñ–∑–º –∞–¥–∞–ø—Ç–∞—Ü—ñ—ó –¥–∞–Ω–∏—Ö –¥–æ –≤–∏–º–æ–≥ –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞, –ø—Ä–∏ —Ü—å–æ–º—É –Ω–µ –º–æ–¥–∏—Ñ—ñ–∫—É—é—á–∏ —Å–∞–º—ñ –∑–Ω–∞—á–µ–Ω–Ω—è —É —Å—Ö–æ–≤–∏—â—ñ. –ó–∞–≤–¥—è–∫–∏ —Ü—å–æ–º—É –≤—Å—ñ –æ–±—á–∏—Å–ª–µ–Ω–Ω—è —É—Å–µ—Ä–µ–¥–Ω–µ–Ω–Ω—è, –ø–æ—à—É–∫—É –º—ñ–Ω—ñ–º–∞–ª—å–Ω–∏—Ö —ñ –º–∞–∫—Å–∏–º–∞–ª—å–Ω–∏—Ö –∑–Ω–∞—á–µ–Ω—å (–æ–ø–∏—Å–∞–Ω—ñ –≤ –ø. 3.2.1.2) –≤–∏–∫–æ–Ω—É—é—Ç—å—Å—è —É –≤–Ω—É—Ç—Ä—ñ—à–Ω—ñ–π —Å–∏—Å—Ç–µ–º—ñ –≤–∏–º—ñ—Ä—é–≤–∞–Ω–Ω—è, –∞ –≤—ñ–∑—É–∞–ª—ñ–∑–∞—Ü—ñ—è –≤—ñ–¥–ø–æ–≤—ñ–¥–∞—î –Ω–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è–º, –≤—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–º —É –ø–µ—Ä—Å–æ–Ω–∞–ª—å–Ω–æ–º—É –ø—Ä–æ—Ñ—ñ–ª—ñ. –ü–µ—Ä–µ—Ö—ñ–¥ –º—ñ–∂ —Å–∏—Å—Ç–µ–º–∞–º–∏ –≤–∏–º—ñ—Ä—é–≤–∞–Ω–Ω—è —î —á–∞—Å—Ç–∏–Ω–æ—é –∑–∞–≥–∞–ª—å–Ω–æ–≥–æ –∞–ª–≥–æ—Ä–∏—Ç–º—É –æ–±—Ä–æ–±–∫–∏ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ —Å—Ç–∞–Ω—Ü—ñ—ó, –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–Ω–æ–≥–æ –Ω–∞ UML-–¥—ñ–∞–≥—Ä–∞–º—ñ –¥—ñ—è–ª—å–Ω–æ—Å—Ç—ñ –Ω–∞ —Ä–∏—Å—É–Ω–∫—É 3.3, –¥–µ –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü—ñ—è –≤–∏–∫–æ–Ω—É—î—Ç—å—Å—è –ø—ñ—Å–ª—è –æ—Ç—Ä–∏–º–∞–Ω–Ω—è –¥–∞–Ω–∏—Ö —Ç–∞ –ø–µ—Ä–µ–¥ —ó—Ö –≤–∫–ª—é—á–µ–Ω–Ω—è–º –¥–æ –ø—ñ–¥—Å—É–º–∫–æ–≤–æ–≥–æ –æ–±‚Äô—î–∫—Ç–∞ DTO.
–ó–∞–≤–¥—è–∫–∏ –≤–ø—Ä–æ–≤–∞–¥–∂–µ–Ω–Ω—é –æ–∫—Ä–µ–º–æ–≥–æ —Å–µ—Ä–≤—ñ—Å—É UnitConversionService –±—ñ–∑–Ω–µ—Å-–ª–æ–≥—ñ–∫–∞ –∑–∞–ª–∏—à–∞—î—Ç—å—Å—è —Ä–æ–∑–¥—ñ–ª–µ–Ω–æ—é, –º–æ–¥—É–ª—å–Ω–æ—é —Ç–∞ –ø—Ä–∏–¥–∞—Ç–Ω–æ—é –¥–æ –º–∞—Å—à—Ç–∞–±—É–≤–∞–Ω–Ω—è ‚Äî –Ω–∞–ø—Ä–∏–∫–ª–∞–¥, –¥–ª—è –¥–æ–¥–∞–≤–∞–Ω–Ω—è –Ω–æ–≤–∏—Ö —Ç–∏–ø—ñ–≤ —Å–µ–Ω—Å–æ—Ä—ñ–≤ —á–∏ –ø—ñ–¥—Ç—Ä–∏–º–∫–∏ –∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω–∏—Ö —Ñ—ñ–∑–∏—á–Ω–∏—Ö –æ–¥–∏–Ω–∏—Ü—å —É –º–∞–π–±—É—Ç–Ω—ñ—Ö –≤–µ—Ä—Å—ñ—è—Ö —Å–∏—Å—Ç–µ–º–∏.

3.2.2 –ê–¥–º—ñ–Ω—ñ—Å—Ç—Ä—É–≤–∞–Ω–Ω—è —Å–µ—Ä–≤–µ—Ä–Ω–æ—ó —á–∞—Å—Ç–∏–Ω–∏
3.2.2.1 –†–µ–∑–µ—Ä–≤–Ω—ñ –∫–æ–ø—ñ—ó –¥–∞–Ω–∏—Ö —Ç–∞ —Å–∏—Å—Ç–µ–º–∏

–£ —Å–∏—Å—Ç–µ–º—ñ —Ä–µ–∞–ª—ñ–∑–æ–≤–∞–Ω–∏–π –ø–æ–≤–Ω–æ—Ü—ñ–Ω–Ω–∏–π –º–æ–¥—É–ª—å —Å—Ç–≤–æ—Ä–µ–Ω–Ω—è —Ç–∞ –∫–µ—Ä—É–≤–∞–Ω–Ω—è —Ä–µ–∑–µ—Ä–≤–Ω–∏–º–∏ –∫–æ–ø—ñ—è–º–∏ (–¥–∏–≤. –¥–æ–¥–∞—Ç–æ–∫ –ì), —â–æ –∑–∞–±–µ–∑–ø–µ—á—É—î –∑–±–µ—Ä–µ–∂–µ–Ω–Ω—è –∫—Ä–∏—Ç–∏—á–Ω–æ –≤–∞–∂–ª–∏–≤–∏—Ö –¥–∞–Ω–∏—Ö —Ç–∞ –º–æ–∂–ª–∏–≤—ñ—Å—Ç—å –≤—ñ–¥–Ω–æ–≤–ª–µ–Ω–Ω—è —Ä–æ–±–æ—Ç–∏ —É —Ä–∞–∑—ñ –∑–±–æ—ó–≤. –ú–µ—Ö–∞–Ω—ñ–∑–º –ø—ñ–¥—Ç—Ä–∏–º—É—î –¥–≤–∞ —Ç–∏–ø–∏ —Ä–µ–∑–µ—Ä–≤—É–≤–∞–Ω–Ω—è: –∫–æ–ø—ñ—é–≤–∞–Ω–Ω—è –ª–∏—à–µ –±–∞–∑–∏ –¥–∞–Ω–∏—Ö —Ç–∞ –ø–æ–≤–Ω–µ —Å–∏—Å—Ç–µ–º–Ω–µ —Ä–µ–∑–µ—Ä–≤–Ω–µ –∫–æ–ø—ñ—é–≤–∞–Ω–Ω—è, —è–∫–µ –≤–∫–ª—é—á–∞—î –æ–¥–Ω–æ—á–∞—Å–Ω–æ –¥–∞–º–ø –ë–î —ñ —Ñ–∞–π–ª–æ–≤—É —Å–∏—Å—Ç–µ–º—É –ø—Ä–æ–µ–∫—Ç—É.
–î–ª—è –∫–æ–Ω—Ç—Ä–æ–ª—é —Å—Ç–∞–Ω—É —Ä–µ–∑–µ—Ä–≤—É–≤–∞–Ω—å —Ä–µ–∞–ª—ñ–∑–æ–≤–∞–Ω–∏–π –º–µ—Ç–æ–¥ getBackupStats(), —è–∫–∏–π –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ –∞–Ω–∞–ª—ñ–∑—É—î –≤—Å—ñ –∑–∞–ø–∏—Å–∏ –≤ —Ç–∞–±–ª–∏—Ü—ñ —Å–∏—Å—Ç–µ–º–Ω–∏—Ö –±–µ–∫–∞–ø—ñ–≤ —ñ –ø–æ–≤–µ—Ä—Ç–∞—î –∞–≥—Ä–µ–≥–æ–≤–∞–Ω—É —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É. –§–æ—Ä–º—É—é—Ç—å—Å—è –∑–Ω–∞—á–µ–Ω–Ω—è –∑–∞–≥–∞–ª—å–Ω–æ—ó –∫—ñ–ª—å–∫–æ—Å—Ç—ñ —Ä–µ–∑–µ—Ä–≤–Ω–∏—Ö –∫–æ–ø—ñ–π, –∫—ñ–ª—å–∫–æ—Å—Ç—ñ —É—Å–ø—ñ—à–Ω–æ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—Ö, —Ç–∏—Ö, —â–æ –≤–∏–∫–æ–Ω–∞–Ω—ñ –∑ –ø–æ–º–∏–ª–∫–æ—é, –∑–Ω–∞—Ö–æ–¥—è—Ç—å—Å—è —É —á–µ—Ä–∑—ñ –∞–±–æ –±—É–ª–∏ —Å–∫–∞—Å–æ–≤–∞–Ω—ñ. –î–æ–¥–∞—Ç–∫–æ–≤–æ –ø—ñ–¥—Ä–∞—Ö–æ–≤—É—î—Ç—å—Å—è –∑–∞–≥–∞–ª—å–Ω–∏–π –æ–±—Å—è–≥ —É—Å–ø—ñ—à–Ω–æ —Å—Ç–≤–æ—Ä–µ–Ω–∏—Ö –±–µ–∫–∞–ø—ñ–≤ —É –º–µ–≥–∞–±–∞–π—Ç–∞—Ö. –¶–µ –¥–∞—î –∑–º–æ–≥—É –∞–¥–º—ñ–Ω—ñ—Å—Ç—Ä–∞—Ç–∏–≤–Ω—ñ–π –ø–∞–Ω–µ–ª—ñ –≤ —Ä–µ–∂–∏–º—ñ —Ä–µ–∞–ª—å–Ω–æ–≥–æ —á–∞—Å—É –≤—ñ–¥–æ–±—Ä–∞–∂–∞—Ç–∏ –ø–æ—Ç–æ—á–Ω–∏–π —Å—Ç–∞–Ω –ø—ñ–¥—Å–∏—Å—Ç–µ–º–∏ —Ä–µ–∑–µ—Ä–≤—É–≤–∞–Ω–Ω—è.
–ü–µ—Ä–µ–¥ —Å—Ç–≤–æ—Ä–µ–Ω–Ω—è–º –Ω–æ–≤–æ–≥–æ –±–µ–∫–∞–ø—É —Å–∏—Å—Ç–µ–º–∞ –≥–∞—Ä–∞–Ω—Ç—É—î –Ω–∞—è–≤–Ω—ñ—Å—Ç—å —Ü—ñ–ª—å–æ–≤–æ–≥–æ –∫–∞—Ç–∞–ª–æ–≥—É. –Ø–∫—â–æ —Ç–∞–∫–∏–π –∫–∞—Ç–∞–ª–æ–≥ –≤—ñ–¥—Å—É—Ç–Ω—ñ–π, –≤—ñ–Ω –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ —Å—Ç–≤–æ—Ä—é—î—Ç—å—Å—è. –ü—ñ—Å–ª—è —Ü—å–æ–≥–æ —Å–∏—Å—Ç–µ–º–∞ —Å—Ç–≤–æ—Ä—é—î –∑–∞–ø–∏—Å —É –ë–î –∑—ñ —Å—Ç–∞—Ç—É—Å–æ–º PENDING —ñ –ø–æ–∑–Ω–∞—á–∫–æ—é —á–∞—Å—É –ø–æ—á–∞—Ç–∫—É –æ–ø–µ—Ä–∞—Ü—ñ—ó. –î–∞–ª—ñ –∑–∞–ª–µ–∂–Ω–æ –≤—ñ–¥ –æ–±—Ä–∞–Ω–æ–≥–æ —Ç–∏–ø—É —Ä–µ–∑–µ—Ä–≤—É–≤–∞–Ω–Ω—è —ñ–Ω—ñ—Ü—ñ—é—î—Ç—å—Å—è –≤—ñ–¥–ø–æ–≤—ñ–¥–Ω–∏–π –≤–Ω—É—Ç—Ä—ñ—à–Ω—ñ–π –ø—Ä–æ—Ü–µ—Å.
–ü—ñ–¥ —á–∞—Å —Å—Ç–≤–æ—Ä–µ–Ω–Ω—è —Ä–µ–∑–µ—Ä–≤–Ω–æ—ó –∫–æ–ø—ñ—ó –±–∞–∑–∏ –¥–∞–Ω–∏—Ö —Ñ–æ—Ä–º—É—î—Ç—å—Å—è —É–Ω—ñ–∫–∞–ª—å–Ω–∞ –Ω–∞–∑–≤–∞ —Ñ–∞–π–ª—É –Ω–∞ –æ—Å–Ω–æ–≤—ñ –º—ñ—Ç–∫–∏ —á–∞—Å—É, –ø—ñ—Å–ª—è —á–æ–≥–æ –≤–∏–∫–ª–∏–∫–∞—î—Ç—å—Å—è —ñ–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç pg_dump. –ö–æ–º–∞–Ω–¥–∞ –≤–∏–∫–æ–Ω—É—î—Ç—å—Å—è –≤ –æ–∫—Ä–µ–º–æ–º—É –¥–æ—á—ñ—Ä–Ω—å–æ–º—É –ø—Ä–æ—Ü–µ—Å—ñ, –∞ —Å–∏—Å—Ç–µ–º–∞ –∑–±–µ—Ä—ñ–≥–∞—î –ø–æ—Å–∏–ª–∞–Ω–Ω—è –Ω–∞ —Ü–µ–π –ø—Ä–æ—Ü–µ—Å –¥–ª—è –º–æ–∂–ª–∏–≤–æ—Å—Ç—ñ –ø–æ–¥–∞–ª—å—à–æ–≥–æ –∫–æ–Ω—Ç—Ä–æ–ª—é —á–∏ —Å–∫–∞—Å—É–≤–∞–Ω–Ω—è. –ü—ñ—Å–ª—è —É—Å–ø—ñ—à–Ω–æ–≥–æ –∑–∞–≤–µ—Ä—à–µ–Ω–Ω—è –æ—Ç—Ä–∏–º–∞–Ω–∏–π –¥–∞–º–ø –ø–µ—Ä–µ–≤—ñ—Ä—è—î—Ç—å—Å—è –Ω–∞ —Ñ–∞–π–ª–æ–≤—É –∫–æ—Ä–µ–∫—Ç–Ω—ñ—Å—Ç—å, –≤–∏–∑–Ω–∞—á–∞—î—Ç—å—Å—è –π–æ–≥–æ —Ä–æ–∑–º—ñ—Ä, —ñ –∑–∞–ø–∏—Å —É –ë–î –æ–Ω–æ–≤–ª—é—î—Ç—å—Å—è –∑—ñ —Å—Ç–∞—Ç—É—Å–æ–º COMPLETED, —á–∞—Å–æ–º –∑–∞–≤–µ—Ä—à–µ–Ω–Ω—è —Ç–∞ —Ñ–∞–∫—Ç–∏—á–Ω–∏–º —Ä–æ–∑–º—ñ—Ä–æ–º —Ñ–∞–π–ª—É. –Ø–∫—â–æ –∂ –ø—ñ–¥ —á–∞—Å –≤–∏–∫–æ–Ω–∞–Ω–Ω—è —Ç—Ä–∞–ø–ª—è—î—Ç—å—Å—è –ø–æ–º–∏–ª–∫–∞, –∑–∞–ø–∏—Å –æ—Ç—Ä–∏–º—É—î —Å—Ç–∞—Ç—É—Å FAILED —Ä–∞–∑–æ–º –∑ —Ç–µ–∫—Å—Ç–æ–º –ø–æ–º–∏–ª–∫–∏ —Ç–∞ –º—ñ—Ç–∫–æ—é –∑–∞–≤–µ—Ä—à–µ–Ω–Ω—è.
–ü–æ–≤–Ω–µ —Å–∏—Å—Ç–µ–º–Ω–µ —Ä–µ–∑–µ—Ä–≤—É–≤–∞–Ω–Ω—è –ø—Ä–∞—Ü—é—î –∑–∞ –∞–Ω–∞–ª–æ–≥—ñ—á–Ω–∏–º –ø—Ä–∏–Ω—Ü–∏–ø–æ–º, –∞–ª–µ –≤–∫–ª—é—á–∞—î –¥–≤–∞ –µ—Ç–∞–ø–∏. –°–ø–æ—á–∞—Ç–∫—É –≤–∏–∫–æ–Ω—É—î—Ç—å—Å—è —Å—Ç–≤–æ—Ä–µ–Ω–Ω—è —Ç–∏–º—á–∞—Å–æ–≤–æ–≥–æ –¥–∞–º–ø—É –±–∞–∑–∏ –¥–∞–Ω–∏—Ö. –ü—ñ—Å–ª—è —Ü—å–æ–≥–æ —Å–∏—Å—Ç–µ–º–∞ —Ñ–æ—Ä–º—É—î –∞—Ä—Ö—ñ–≤ tar.gz, –¥–æ —è–∫–æ–≥–æ –≤–∫–ª—é—á–∞—î –æ—Ç—Ä–∏–º–∞–Ω–∏–π –¥–∞–º–ø —Ç–∞ –∫–∞—Ç–∞–ª–æ–≥ —Ñ–∞–π–ª—ñ–≤ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω—å –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á—ñ–≤ (—è–∫—â–æ –≤—ñ–Ω —ñ—Å–Ω—É—î). –¶–µ –¥–æ–∑–≤–æ–ª—è—î —Å—Ç–≤–æ—Ä–∏—Ç–∏ –∫–æ–º–ø–ª–µ–∫—Å–Ω—É —Ä–µ–∑–µ—Ä–≤–Ω—É –∫–æ–ø—ñ—é –≤—Å—ñ—î—ó —ñ–Ω—Ñ—Ä–∞—Å—Ç—Ä—É–∫—Ç—É—Ä–∏ –∫–æ—Ä–∏—Å—Ç—É–≤–∞—Ü—å–∫–∏—Ö –¥–∞–Ω–∏—Ö. –ü—ñ—Å–ª—è –∑–∞–≤–µ—Ä—à–µ–Ω–Ω—è –∞—Ä—Ö—ñ–≤–∞—Ü—ñ—ó —Ç–∏–º—á–∞—Å–æ–≤–∏–π –¥–∞–º–ø –≤–∏–¥–∞–ª—è—î—Ç—å—Å—è. –û—Ç—Ä–∏–º–∞–Ω–∏–π –∞—Ä—Ö—ñ–≤ –ø–µ—Ä–µ–≤—ñ—Ä—è—î—Ç—å—Å—è, –≤–∏–º—ñ—Ä—é—î—Ç—å—Å—è –π–æ–≥–æ —Ä–æ–∑–º—ñ—Ä, –∞ –∑–∞–ø–∏—Å —É –ë–î –æ–Ω–æ–≤–ª—é—î—Ç—å—Å—è —è–∫ —É—Å–ø—ñ—à–Ω–∏–π. –ó–∞ –±—É–¥—å-—è–∫–æ—ó –ø–æ–º–∏–ª–∫–∏ —Ä–µ–∑–µ—Ä–≤—É–≤–∞–Ω–Ω—è –ø–æ–∑–Ω–∞—á–∞—î—Ç—å—Å—è —è–∫ –Ω–µ–≤–¥–∞–ª–µ –∑ –≤—ñ–¥–ø–æ–≤—ñ–¥–Ω–∏–º –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è–º —É –ø–æ–ª—ñ errorMessage.

3.2.2.2 –ó–∞–ø–∏—Å —Å–∏—Å—Ç–µ–º–Ω–∏—Ö –ø–æ–¥—ñ–π —Ç–∞ –∞–Ω–∞–ª—ñ—Ç–∏–∫–∞ —Å—Ç–∞–Ω—É —Å–∏—Å—Ç–µ–º–∏

–£ —Å–∏—Å—Ç–µ–º—ñ —Ä–µ–∞–ª—ñ–∑–æ–≤–∞–Ω–∏–π —Ä–æ–∑—à–∏—Ä–µ–Ω–∏–π –º–µ—Ö–∞–Ω—ñ–∑–º –∫–æ–Ω—Ç—Ä–æ–ª—é –ø—Ä–∞—Ü–µ–∑–¥–∞—Ç–Ω–æ—Å—Ç—ñ —Ç–∞ –º–æ–Ω—ñ—Ç–æ—Ä–∏–Ω–≥—É, —è–∫–∏–π –ø–æ—î–¥–Ω—É—î —Ä–µ–≥—É–ª—è—Ä–Ω—ñ –ø–µ—Ä–µ–≤—ñ—Ä–∫–∏ —Å—Ç–∞–Ω—É –æ—Å–Ω–æ–≤–Ω–∏—Ö –ø—ñ–¥—Å–∏—Å—Ç–µ–º, –∑–∞–ø–∏—Å —Å–∏—Å—Ç–µ–º–Ω–∏—Ö –ø–æ–¥—ñ–π —ñ –≥–µ–Ω–µ—Ä–∞—Ü—ñ—é —É–∑–∞–≥–∞–ª—å–Ω–µ–Ω–æ—ó –∞–Ω–∞–ª—ñ—Ç–∏–∫–∏ –∑–∞ –æ–±—Ä–∞–Ω–∏–π –ø–µ—Ä—ñ–æ–¥. –¶–µ–π –º–æ–¥—É–ª—å –∑–∞–±–µ–∑–ø–µ—á—É—î –≤–∏—Å–æ–∫—É –ø—Ä–æ–∑–æ—Ä—ñ—Å—Ç—å —Ä–æ–±–æ—Ç–∏ —Å–µ—Ä–≤–µ—Ä–Ω–æ—ó —á–∞—Å—Ç–∏–Ω–∏, —Å–ø—Ä–æ—â—É—î –¥—ñ–∞–≥–Ω–æ—Å—Ç–∏–∫—É –ø–æ–º–∏–ª–æ–∫ —ñ –¥–æ–∑–≤–æ–ª—è—î —Å–≤–æ—î—á–∞—Å–Ω–æ —Ä–µ–∞–≥—É–≤–∞—Ç–∏ –Ω–∞ –∫—Ä–∏—Ç–∏—á–Ω—ñ –∑–º—ñ–Ω–∏ —É —Ä–æ–±–æ—Ç—ñ –ø—Ä–æ–≥—Ä–∞–º–Ω–æ—ó —ñ–Ω—Ñ—Ä–∞—Å—Ç—Ä—É–∫—Ç—É—Ä–∏.
–û—Å–Ω–æ–≤–æ—é –ø—ñ–¥—Å–∏—Å—Ç–µ–º–∏ —î –º–µ—Ç–æ–¥ –æ—Ç—Ä–∏–º–∞–Ω–Ω—è –∑–∞–≥–∞–ª—å–Ω–æ–≥–æ —Å—Ç–∞–Ω—É —Å–∏—Å—Ç–µ–º–∏ (–¥–∏–≤. –¥–æ–¥–∞—Ç–æ–∫ –î), —è–∫–∏–π –≤–∏–∫–æ–Ω—É—î –∫–æ–º–ø–ª–µ–∫—Å–Ω—É –ø–µ—Ä–µ–≤—ñ—Ä–∫—É –∫—ñ–ª—å–∫–æ—Ö –∫–ª—é—á–æ–≤–∏—Ö —Ä–µ—Å—É—Ä—Å—ñ–≤. –î–æ –Ω–∏—Ö –Ω–∞–ª–µ–∂–∞—Ç—å –±–∞–∑–∞ –¥–∞–Ω–∏—Ö, —Ñ–∞–π–ª–æ–≤–∏–π –¥–∏—Å–∫, –æ–ø–µ—Ä–∞—Ç–∏–≤–Ω–∞ –ø–∞–º‚Äô—è—Ç—å —Ç–∞ –ø—Ä–æ—Ü–µ—Å–æ—Ä–Ω–µ –Ω–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è. –ö–æ–∂–Ω–∞ –ø–µ—Ä–µ–≤—ñ—Ä–∫–∞ –∑–¥—ñ–π—Å–Ω—é—î—Ç—å—Å—è –æ–∫—Ä–µ–º–∏–º –≤–Ω—É—Ç—Ä—ñ—à–Ω—ñ–º –º–µ—Ç–æ–¥–æ–º: —Ç–µ—Å—Ç–æ–≤–∞ SQL-–∫–æ–º–∞–Ω–¥–∞ –≤–∏–∑–Ω–∞—á–∞—î –¥–æ—Å—Ç—É–ø–Ω—ñ—Å—Ç—å —ñ —á–∞—Å –≤—ñ–¥–ø–æ–≤—ñ–¥—ñ –±–∞–∑–∏ –¥–∞–Ω–∏—Ö; –º–æ–¥—É–ª—å –∫–æ–Ω—Ç—Ä–æ–ª—é –¥–∏—Å–∫–∞ –æ—Ü—ñ–Ω—é—î –π–æ–≥–æ –∑–∞–ø–æ–≤–Ω–µ–Ω—ñ—Å—Ç—å —Ç–∞ –¥–æ—Å—Ç—É–ø–Ω–∏–π –ø—Ä–æ—Å—Ç—ñ—Ä; –∞–Ω–∞–ª—ñ–∑ –ø—ñ–¥—Å–∏—Å—Ç–µ–º–∏ –ø–∞–º‚Äô—è—Ç—ñ –≤–∏–∑–Ω–∞—á–∞—î –≤—ñ–¥—Å–æ—Ç–æ–∫ –≤–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è —Ç–∞ —Ä–∏–∑–∏–∫ –ø–µ—Ä–µ—Ö–æ–¥—É –≤ –∫—Ä–∏—Ç–∏—á–Ω–∏–π —Å—Ç–∞–Ω; –æ—Ü—ñ–Ω–∫–∞ –Ω–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è CPU “ë—Ä—É–Ω—Ç—É—î—Ç—å—Å—è –Ω–∞ —É—Å–µ—Ä–µ–¥–Ω–µ–Ω–∏—Ö –∑–Ω–∞—á–µ–Ω–Ω—è—Ö —Å–∏—Å—Ç–µ–º–Ω–æ–≥–æ load average. –†–µ–∑—É–ª—å—Ç–∞—Ç–∏ —Ü–∏—Ö –ø–µ—Ä–µ–≤—ñ—Ä–æ–∫ —Ñ–æ—Ä–º—É—é—Ç—å —Å—Ç—Ä—É–∫—Ç—É—Ä—É –∑–¥–æ—Ä–æ–≤‚Äô—è —Å–∏—Å—Ç–µ–º–∏, —É —è–∫—ñ–π –∫–æ–∂–µ–Ω –∫–æ–º–ø–æ–Ω–µ–Ω—Ç –º–∞—î —Å—Ç–∞—Ç—É—Å ¬´healthy¬ª, ¬´warning¬ª –∞–±–æ ¬´critical¬ª, –∞ –∑–∞–≥–∞–ª—å–Ω–∏–π —Å—Ç–∞–Ω –≤–∏–∑–Ω–∞—á–∞—î—Ç—å—Å—è –∑–∞ –Ω–∞—è–≤–Ω—ñ—Å—Ç—é —Ö–æ—á–∞ –± –æ–¥–Ω—ñ—î—ó –Ω–µ–≤–¥–∞–ª–æ—ó –ø–µ—Ä–µ–≤—ñ—Ä–∫–∏.
–ö—Ä—ñ–º –∫–æ–Ω—Ç—Ä–æ–ª—é –ø—Ä–∞—Ü–µ–∑–¥–∞—Ç–Ω–æ—Å—Ç—ñ —Ä–µ—Å—É—Ä—Å—ñ–≤, —Å–∏—Å—Ç–µ–º–∞ –≤—ñ–¥—Å—Ç–µ–∂—É—î –∑–∞–≥–∞–ª—å–Ω–∏–π —á–∞—Å –±–µ–∑–ø–µ—Ä–µ—Ä–≤–Ω–æ—ó —Ä–æ–±–æ—Ç–∏. –î–ª—è —Ü—å–æ–≥–æ —Ñ–æ—Ä–º—É—î—Ç—å—Å—è –æ–±‚Äô—î–∫—Ç –∑ –∫—ñ–ª—å–∫—ñ—Å—Ç—é —Å–µ–∫—É–Ω–¥ uptime, –≤—ñ–¥—Ñ–æ—Ä–º–∞—Ç–æ–≤–∞–Ω–∏–º –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–Ω—è–º —Ç–∞ –ø–æ–∑–Ω–∞—á–∫–æ—é —á–∞—Å—É –æ—Å—Ç–∞–Ω–Ω—å–æ–≥–æ –ø–µ—Ä–µ–∑–∞–ø—É—Å–∫—É. –¢–∞–∫–∞ —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—è –∫–æ—Ä–∏—Å–Ω–∞ –ø—ñ–¥ —á–∞—Å –∞–Ω–∞–ª—ñ–∑—É —Å—Ç–∞–±—ñ–ª—å–Ω–æ—Å—Ç—ñ —Å–µ—Ä–≤–µ—Ä–Ω–æ–≥–æ –æ—Ç–æ—á–µ–Ω–Ω—è —Ç–∞ –≤–∏—è–≤–ª–µ–Ω–Ω—è —Ü–∏–∫–ª—ñ—á–Ω–∏—Ö –∑–±–æ—ó–≤.
–í–∞–∂–ª–∏–≤–æ—é —á–∞—Å—Ç–∏–Ω–æ—é –º–æ–¥—É–ª—è —î –º–µ—Ö–∞–Ω—ñ–∑–º –∑–±–æ—Ä—É —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –∑–∞ –ø–µ–≤–Ω–∏–π —á–∞—Å–æ–≤–∏–π –ø–µ—Ä—ñ–æ–¥. –ö–æ—Ä–∏—Å—Ç—É–≤–∞—á –º–æ–∂–µ –æ—Ç—Ä–∏–º–∞—Ç–∏ –∞–Ω–∞–ª—ñ—Ç–∏–∫—É –∑–∞ –¥–æ–±—É, —Ç–∏–∂–¥–µ–Ω—å –∞–±–æ –º—ñ—Å—è—Ü—å, –ø—ñ—Å–ª—è —á–æ–≥–æ —Å–∏—Å—Ç–µ–º–∞ –≤–∏–∑–Ω–∞—á–∞—î –ø–æ—á–∞—Ç–æ–∫ –≤–∏–±—Ä–∞–Ω–æ–≥–æ —ñ–Ω—Ç–µ—Ä–≤–∞–ª—É —Ç–∞ –≤–∏–∫–æ–Ω—É—î –Ω–∏–∑–∫—É –∞–≥—Ä–µ–≥–æ–≤–∞–Ω–∏—Ö –∑–∞–ø–∏—Ç—ñ–≤ –¥–æ –±–∞–∑–∏ –¥–∞–Ω–∏—Ö. –ó–æ–∫—Ä–µ–º–∞, –ø—Ä–æ–≤–æ–¥–∏—Ç—å—Å—è –≥—Ä—É–ø—É–≤–∞–Ω–Ω—è —Å–∏—Å—Ç–µ–º–Ω–∏—Ö –ø–æ–¥—ñ–π –∑–∞ —ó—Ö —Ç–∏–ø–∞–º–∏, –æ–±—á–∏—Å–ª—é—î—Ç—å—Å—è –∑–∞–≥–∞–ª—å–Ω–∞ –∫—ñ–ª—å–∫—ñ—Å—Ç—å –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á—ñ–≤ —Ç–∞ —á–∏—Å–ª–æ –Ω–æ–≤–∏—Ö —Ä–µ—î—Å—Ç—Ä–∞—Ü—ñ–π –∑–∞ –≤–∏–±—Ä–∞–Ω–∏–π –ø–µ—Ä—ñ–æ–¥, –ø—ñ–¥—Ä–∞—Ö–æ–≤—É—î—Ç—å—Å—è –∫—ñ–ª—å–∫—ñ—Å—Ç—å –∑–∞—Ñ—ñ–∫—Å–æ–≤–∞–Ω–∏—Ö –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–µ–π —É –∂—É—Ä–Ω–∞–ª—ñ –¥—ñ–π –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á—ñ–≤, –∞ —Ç–∞–∫–æ–∂ –≤–∏–∑–Ω–∞—á–∞—é—Ç—å—Å—è —Å—Ç–∞—Ç—É—Å–∏ —Å—Ç–≤–æ—Ä–µ–Ω–∏—Ö —Ä–µ–∑–µ—Ä–≤–Ω–∏—Ö –∫–æ–ø—ñ–π. –ö—Ä—ñ–º —Ü—å–æ–≥–æ, –≤ –∞–Ω–∞–ª—ñ—Ç–∏—á–Ω–∏–π –∑–≤—ñ—Ç –≤–∫–ª—é—á–∞—î—Ç—å—Å—è –∞–∫—Ç—É–∞–ª—å–Ω–∏–π —Å—Ç–∞–Ω —Å–∏—Å—Ç–µ–º–∏ –Ω–∞ –º–æ–º–µ–Ω—Ç –∑–∞–ø–∏—Ç—É, —â–æ –¥–æ–∑–≤–æ–ª—è—î –∑—ñ—Å—Ç–∞–≤–ª—è—Ç–∏ —ñ—Å—Ç–æ—Ä–∏—á–Ω—ñ –¥–∞–Ω—ñ –∑ –ø–æ—Ç–æ—á–Ω–∏–º —Å—Ç–∞–Ω–æ–º —Å–µ—Ä–≤–µ—Ä–Ω–∏—Ö —Ä–µ—Å—É—Ä—Å—ñ–≤.
–ó–∞–≤–¥—è–∫–∏ —Ç–∞–∫—ñ–π —Å—Ç—Ä—É–∫—Ç—É—Ä—ñ –º–æ–¥—É–ª—å –Ω–∞–¥–∞—î –ø–æ–≤–Ω–æ–º–∞—Å—à—Ç–∞–±–Ω–µ –±–∞—á–µ–Ω–Ω—è —Ä–æ–±–æ—Ç–∏ —Å–∏—Å—Ç–µ–º–∏: –≤—ñ–¥ –Ω–∏–∑—å–∫–æ—Ä—ñ–≤–Ω–µ–≤–∏—Ö –ø–æ–∫–∞–∑–Ω–∏–∫—ñ–≤ –ø—Ä–æ–¥—É–∫—Ç–∏–≤–Ω–æ—Å—Ç—ñ –¥–æ –≤–∏—Å–æ–∫–æ—Ä—ñ–≤–Ω–µ–≤–∏—Ö –±—ñ–∑–Ω–µ—Å-–º–µ—Ç—Ä–∏–∫ —Ç–∞ –≤–∑–∞—î–º–æ–¥—ñ—ó –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á—ñ–≤.




3.2.2.3 –ï–∫—Å–ø–æ—Ä—Ç –¥–∞–Ω–∏—Ö

–£ —Å–∏—Å—Ç–µ–º—ñ —Ä–µ–∞–ª—ñ–∑–æ–≤–∞–Ω–æ –ø–æ–≤–Ω–æ—Ü—ñ–Ω–Ω–∏–π –º–µ—Ö–∞–Ω—ñ–∑–º –µ–∫—Å–ø–æ—Ä—Ç—É –¥–∞–Ω–∏—Ö, —â–æ –¥–æ–∑–≤–æ–ª—è—î –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞–º –∑–∞–≤–∞–Ω—Ç–∞–∂—É–≤–∞—Ç–∏ —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—é –ø—Ä–æ –≤–∏–º—ñ—Ä—é–≤–∞–Ω–Ω—è, —Å–ø–æ–≤—ñ—â–µ–Ω–Ω—è —Ç–∞ –∞–≥—Ä–µ–≥–æ–≤–∞–Ω—É –∞–Ω–∞–ª—ñ—Ç–∏–∫—É —É –∑—Ä—É—á–Ω–∏—Ö —Ñ–æ—Ä–º–∞—Ç–∞—Ö. –ü—Ä–æ—Ü–µ—Å –µ–∫—Å–ø–æ—Ä—Ç—É –ø–æ—á–∏–Ω–∞—î—Ç—å—Å—è –∑—ñ —Å—Ç–≤–æ—Ä–µ–Ω–Ω—è –∑–∞–ø–∏—Ç—É, –ø—ñ–¥ —á–∞—Å —è–∫–æ–≥–æ —Å–µ—Ä–≤–µ—Ä —ñ–¥–µ–Ω—Ç–∏—Ñ—ñ–∫—É—î –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞ –∑–∞ —Ç–æ–∫–µ–Ω–æ–º, –ø–µ—Ä–µ–≤—ñ—Ä—è—î –π–æ–≥–æ —ñ—Å–Ω—É–≤–∞–Ω–Ω—è —Ç–∞ —Ñ–æ—Ä–º—É—î –Ω–æ–≤–∏–π –∑–∞–ø–∏—Å —É —Ç–∞–±–ª–∏—Ü—ñ DataExport –∑—ñ —Å—Ç–∞—Ç—É—Å–æ–º PENDING. –ü—ñ—Å–ª—è —Ü—å–æ–≥–æ –µ–∫—Å–ø–æ—Ä—Ç –∑–∞–ø—É—Å–∫–∞—î—Ç—å—Å—è —É —Ñ–æ–Ω–æ–≤–æ–º—É —Ä–µ–∂–∏–º—ñ, —â–æ –¥–æ–∑–≤–æ–ª—è—î –Ω–µ –±–ª–æ–∫—É–≤–∞—Ç–∏ –æ—Å–Ω–æ–≤–Ω–∏–π –ø–æ—Ç—ñ–∫ –æ–±—Ä–æ–±–∫–∏ –∑–∞–ø–∏—Ç—ñ–≤.
–£ —Ö–æ–¥—ñ –æ–±—Ä–æ–±–∫–∏ —Å–µ—Ä–≤–µ—Ä –∑–º—ñ–Ω—é—î —Å—Ç–∞—Ç—É—Å –∑–∞–ø–∏—Ç—É –Ω–∞ PROCESSING —Ç–∞ –æ—Ç—Ä–∏–º—É—î –¥–∞–Ω—ñ –≤—ñ–¥–ø–æ–≤—ñ–¥–Ω–æ –¥–æ –ø–µ—Ä–µ–¥–∞–Ω–∏—Ö —Ñ—ñ–ª—å—Ç—Ä—ñ–≤: —á–∞—Å–æ–≤–∏—Ö –º–µ–∂, —Ç–∏–ø—ñ–≤ —Å–µ–Ω—Å–æ—Ä—ñ–≤, —Å—Ç–∞–Ω—Ü—ñ–π, —Ä—ñ–≤–Ω—ñ–≤ —Å–µ—Ä–π–æ–∑–Ω–æ—Å—Ç—ñ —Å–ø–æ–≤—ñ—â–µ–Ω—å, –∞ —Ç–∞–∫–æ–∂ –¥–æ–¥–∞—Ç–∫–æ–≤–∏—Ö –ø–∞—Ä–∞–º–µ—Ç—Ä—ñ–≤, —â–æ –≤–∏–∑–Ω–∞—á–∞—é—Ç—å, —è–∫—ñ —Å–∞–º–µ –Ω–∞–±–æ—Ä–∏ –¥–∞–Ω–∏—Ö –≤–∫–ª—é—á–∞—Ç–∏ (–≤–∏–º—ñ—Ä—é–≤–∞–Ω–Ω—è, —Å–ø–æ–≤—ñ—â–µ–Ω–Ω—è, –∞–≥—Ä–µ–≥–æ–≤–∞–Ω—ñ –¥–∞–Ω—ñ). –§—ñ–ª—å—Ç—Ä–∞—Ü—ñ—è –≤–∏–∫–æ–Ω—É—î—Ç—å—Å—è –Ω–∞ —Ä—ñ–≤–Ω—ñ –±–∞–∑–∏ –¥–∞–Ω–∏—Ö, —â–æ –∑–∞–±–µ–∑–ø–µ—á—É—î –µ—Ñ–µ–∫—Ç–∏–≤–Ω—ñ—Å—Ç—å –Ω–∞–≤—ñ—Ç—å –¥–ª—è –≤–µ–ª–∏–∫–∏—Ö –æ–±—Å—è–≥—ñ–≤ —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—ó.
–ü—ñ—Å–ª—è —Ñ–æ—Ä–º—É–≤–∞–Ω–Ω—è –≤–∏–±—ñ—Ä–∫–∏ —Å–∏—Å—Ç–µ–º–∞ –≥–µ–Ω–µ—Ä—É—î —Ñ–∞–π–ª —É —Ñ–æ—Ä–º–∞—Ç—ñ CSV, JSON, Excel –∞–±–æ PDF. –ü—ñ—Å–ª—è —É—Å–ø—ñ—à–Ω–æ–≥–æ —Ñ–æ—Ä–º—É–≤–∞–Ω–Ω—è —Ñ–∞–π–ª –∑–±–µ—Ä—ñ–≥–∞—î—Ç—å—Å—è —É —Ñ–∞–π–ª–æ–≤—ñ–π —Å–∏—Å—Ç–µ–º—ñ –∑ –º–æ–∂–ª–∏–≤—ñ—Å—Ç—é –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è, –∞ –∑–∞–ø–∏—Å –µ–∫—Å–ø–æ—Ä—Ç—É –æ–Ω–æ–≤–ª—é—î—Ç—å—Å—è –∑—ñ —Å—Ç–∞—Ç—É—Å–æ–º COMPLETED, —à–ª—è—Ö–æ–º –¥–æ —Ñ–∞–π–ª—É —Ç–∞ –º–µ—Ç–∞–¥–∞–Ω–∏–º–∏ (–Ω–∞–∑–≤–∞, —Ä–æ–∑–º—ñ—Ä).
–£ —Ä–∞–∑—ñ –≤–∏–Ω–∏–∫–Ω–µ–Ω–Ω—è –ø–æ–º–∏–ª–∫–∏ –±—É–¥—å-—è–∫–æ–≥–æ –µ—Ç–∞–ø—É –µ–∫—Å–ø–æ—Ä—Ç –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ –ø–µ—Ä–µ–≤–æ–¥–∏—Ç—å—Å—è —É —Å—Ç–∞—Ç—É—Å FAILED, –∞ –≤ –∂—É—Ä–Ω–∞–ª—ñ —Ä–µ—î—Å—Ç—Ä—É—î—Ç—å—Å—è –¥–µ—Ç–∞–ª—å–Ω–∏–π –æ–ø–∏—Å –ø—Ä–æ–±–ª–µ–º–∏.

3.3 –í–∏—Å–Ω–æ–≤–æ–∫

–£ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ñ —Ä–æ–∑—Ä–æ–±–∫–∏ –±—ñ–∑–Ω–µ—Å-–ª–æ–≥—ñ–∫–∏ —Ç–∞ –º–æ–¥—É–ª—ñ–≤ –∞–¥–º—ñ–Ω—ñ—Å—Ç—Ä—É–≤–∞–Ω–Ω—è –±—É–ª–æ —Å—Ñ–æ—Ä–º–æ–≤–∞–Ω–æ —Ü—ñ–ª—ñ—Å–Ω—É —Å–µ—Ä–≤–µ—Ä–Ω—É —ñ–Ω—Ñ—Ä–∞—Å—Ç—Ä—É–∫—Ç—É—Ä—É, —è–∫–∞ –∑–∞–±–µ–∑–ø–µ—á—É—î –∫–æ—Ä–µ–∫—Ç–Ω–∏–π –ø—Ä–∏–π–æ–º, –æ–±—Ä–æ–±–∫—É —Ç–∞ –∑–±–µ—Ä—ñ–≥–∞–Ω–Ω—è –¥–∞–Ω–∏—Ö —Å–µ–Ω—Å–æ—Ä—ñ–≤, –∞ —Ç–∞–∫–æ–∂ –∫–æ–Ω—Ç—Ä–æ–ª—å –∑–∞ —Å—Ç–∞–Ω–æ–º —Å–∏—Å—Ç–µ–º–∏ –≤ —Ä–µ–∂–∏–º—ñ —Ä–µ–∞–ª—å–Ω–æ–≥–æ —á–∞—Å—É. –†–µ–∞–ª—ñ–∑–æ–≤–∞–Ω—ñ –º–æ–¥—É–ª—ñ –¥–æ–∑–≤–æ–ª—è—é—Ç—å –≥–Ω—É—á–∫–æ –∫–µ—Ä—É–≤–∞—Ç–∏ —Å—Ç–∞–Ω—Ü—ñ—è–º–∏, —Å–µ–Ω—Å–æ—Ä–∞–º–∏, –ø–æ—Ä–æ–≥–∞–º–∏ —Ç–∞ —Å–ø–æ–≤—ñ—â–µ–Ω–Ω—è–º–∏, –∑–∞–±–µ–∑–ø–µ—á—É—é—á–∏ –ø–æ–≤–Ω—É –ø—ñ–¥—Ç—Ä–∏–º–∫—É CRUD-–æ–ø–µ—Ä–∞—Ü—ñ–π —Ç–∞ –º–µ—Ö–∞–Ω—ñ–∑–º—ñ–≤ –ø–µ—Ä–µ–≤—ñ—Ä–∫–∏ —è–∫–æ—Å—Ç—ñ –¥–∞–Ω–∏—Ö —ñ –≥–µ–Ω–µ—Ä–∞—Ü—ñ—ó –ø–æ–ø–µ—Ä–µ–¥–∂–µ–Ω—å. –Ü–Ω—Ç–µ–≥—Ä–∞—Ü—ñ—è –ª–æ–≥—É–≤–∞–Ω–Ω—è, —Å–∏—Å—Ç–µ–º–∏ —Å–ø–æ–≤—ñ—â–µ–Ω—å —Ç–∞ —ñ–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ñ–≤ –∞–¥–º—ñ–Ω—ñ—Å—Ç—Ä—É–≤–∞–Ω–Ω—è –ø—ñ–¥–≤–∏—â–∏–ª–∞ –Ω–∞–¥—ñ–π–Ω—ñ—Å—Ç—å —ñ –ø—Ä–æ–∑–æ—Ä—ñ—Å—Ç—å —Ä–æ–±–æ—Ç–∏ —Å–µ—Ä–≤–µ—Ä–∞, –∞ —á—ñ—Ç–∫–∞ —Å—Ç—Ä—É–∫—Ç—É—Ä–∏–∑–∞—Ü—ñ—è –±—ñ–∑–Ω–µ—Å-–ª–æ–≥—ñ–∫–∏ —Å–ø—Ä–æ—Å—Ç–∏–ª–∞ –º–∞—Å—à—Ç–∞–±—É–≤–∞–Ω–Ω—è —Ç–∞ –ø–æ–¥–∞–ª—å—à–∏–π —Ä–æ–∑–≤–∏—Ç–æ–∫ –ø—Ä–æ—î–∫—Ç—É.
















–ü–ï–†–ï–õ–Ü–ö –î–ñ–ï–†–ï–õ –ü–û–°–ò–õ–ê–ù–ù–Ø
1. GitHub - NureKachuraDiana/arkpz-pzpi-23-6-kachura-diana. GitHub. URL:  https://github.com/NureKachuraDiana/arkpz-pzpi-23-6-kachura-diana.
2. YouTube: https://youtu.be/Rfnwh2lecPo

‚ÄÉ
–î–æ–¥–∞—Ç–æ–∫ –ê
–°–µ—Ä–≤—ñ—Å –∑–∞–ø–∏—Å—É –ø–æ–∫–∞–∑–Ω–∏–∫—ñ–≤ —Å–µ–Ω—Å–æ—Ä—ñ–≤

 
/**
     * Find sensor by serial number with proper error handling
     */
    private async findSensorBySerialNumber(serialNumber: string) {
        const sensor = await this.prisma.sensor.findFirst({
            where: {
                serialNumber,
                isActive: true,
            },
            include: {
                station: true,
            },
        });

        if (!sensor) {
            throw new NotFoundException(`Sensor with serial number '${serialNumber}' not found or inactive`);
        }

        return sensor;
    }

    /**
     * Convert Prisma reading to response DTO
     */
    private toResponseDto(reading: any, thresholdViolations?: any[]): SensorReadingResponseDto {
        return {
            id: reading.id,
            sensorId: reading.sensorId,
            value: reading.value,
            unit: reading.unit,
            timestamp: reading.timestamp,
            quality: reading.quality,
            sensor: {
                id: reading.sensor.id,
                serialNumber: reading.sensor.serialNumber,
                type: reading.sensor.type,
                name: reading.sensor.name,
                station: {
                    id: reading.sensor.station.id,
                    name: reading.sensor.station.name,
                },
            },
            thresholdViolations: thresholdViolations,
        };
    }

    /**
     * Create a new sensor reading with data validation and quality assessment
     */
    async createReading(createSensorReadingDto: CreateSensorReadingDto): Promise<SensorReadingResponseDto> {
        try {
            // Find sensor by serial number
            const sensor = await this.findSensorBySerialNumber(createSensorReadingDto.sensorSerialNumber);

            // Validate reading against thresholds
            const thresholdViolations = await this.thresholdService.validateSensorReading(
                sensor.type,
                createSensorReadingDto.value
            );

            // Calculate data quality (1.0 - severity weight of violations)
            let quality = createSensorReadingDto.quality || 1.0;
            if (thresholdViolations.length > 0) {
                const maxSeverity = Math.max(
                    ...thresholdViolations.map(v => this.getSeverityWeight(v.severity))
                );
                quality = Math.max(0, 1.0 - maxSeverity);
            }

            // Create the reading
            const reading = await this.prisma.sensorReading.create({
                data: {
                    sensorId: sensor.id,
                    value: createSensorReadingDto.value,
                    unit: createSensorReadingDto.unit,
                    timestamp: createSensorReadingDto.timestamp || new Date(),
                    quality: quality,
                },
                include: {
                    sensor: {
                        include: {
                            station: true,
                        },
                    },
                },
            });

            // Create alerts for threshold violations using StationAlertService
            if (thresholdViolations.length > 0) {
                await this.createThresholdAlerts(reading, thresholdViolations, sensor.type);
            }

            this.logger.log(`Created reading for sensor ${sensor.serialNumber} with value ${reading.value}`);

            return this.toResponseDto(reading, thresholdViolations.length > 0 ? thresholdViolations : undefined);

        } catch (error) {
            this.logger.error(`Failed to create sensor reading: ${error.message}`, error.stack);
            throw error;
        }
    }

    /**
     * Get sensor readings for a specific time period
     */
    async getReadings(query: GetReadingsQueryDto): Promise<SensorReadingResponseDto[]> {
        try {
            const { sensorSerialNumber, stationId, sensorType, startTime, endTime } = query;

            if (startTime >= endTime) {
                throw new BadRequestException('Start time must be before end time');
            }

            const whereCondition: any = {
                timestamp: {
                    gte: startTime,
                    lte: endTime,
                },
            };

            if (sensorSerialNumber) {
                // Find sensor by serial number first
                const sensor = await this.findSensorBySerialNumber(sensorSerialNumber);
                whereCondition.sensorId = sensor.id;
            } else if (stationId || sensorType) {
                whereCondition.sensor = {};

                if (stationId) {
                    whereCondition.sensor.stationId = stationId;
                }

                if (sensorType) {
                    whereCondition.sensor.type = sensorType;
                }
            }

            const readings = await this.prisma.sensorReading.findMany({
                where: whereCondition,
                include: {
                    sensor: {
                        include: {
                            station: true,
                        },
                    },
                },
                orderBy: {
                    timestamp: 'asc',
                },
            });

            return readings.map(reading => this.toResponseDto(reading));
        } catch (error) {
            this.logger.error(`Failed to get readings: ${error.message}`, error.stack);
            throw error;
        }
    }

    /**
     * Get latest readings for a sensor or station
     */
    async getLatestReadings(sensorSerialNumber?: string, stationId?: number, limit: number = 10): Promise<SensorReadingResponseDto[]> {
        try {
            if (!sensorSerialNumber && !stationId) {
                throw new BadRequestException('Either sensorSerialNumber or stationId must be provided');
            }

            let query: any;

            if (sensorSerialNumber) {
                // Find sensor by serial number first
                const sensor = await this.findSensorBySerialNumber(sensorSerialNumber);

                // Get latest readings for specific sensor
                query = {
                    where: { sensorId: sensor.id },
                    orderBy: { timestamp: 'desc' },
                    take: limit,
                    include: {
                        sensor: {
                            include: {
                                station: true,
                            },
                        },
                    },
                };
            } else {
                // Get latest readings for all sensors in station
                query = {
                    where: {
                        sensor: {
                            stationId: stationId,
                        },
                    },
                    orderBy: [
                        { sensorId: 'asc' },
                        { timestamp: 'desc' },
                    ],
                    include: {
                        sensor: {
                            include: {
                                station: true,
                            },
                        },
                    },
                };
            }

            const readings = await this.prisma.sensorReading.findMany(query);

            // For station query, we need to get only the latest reading per sensor
            let resultReadings = readings;
            if (stationId && !sensorSerialNumber) {
                const latestBySensor = new Map();
                readings.forEach(reading => {
                    if (!latestBySensor.has(reading.sensorId)) {
                        latestBySensor.set(reading.sensorId, reading);
                    }
                });
                resultReadings = Array.from(latestBySensor.values());
            }

            return resultReadings.map(reading => this.toResponseDto(reading));
        } catch (error) {
            this.logger.error(`Failed to get latest readings: ${error.message}`, error.stack);
            throw error;
        }
    }

    /**
     * Get aggregated data (average, min, max) for a period
     */
    async getAggregatedData(query: AggregationQueryDto) {
        try {
            const { sensorSerialNumber, stationId, sensorType, startTime, endTime, interval } = query;

            if (startTime >= endTime) {
                throw new BadRequestException('Start time must be before end time');
            }

            let sensorId: number | undefined;

            if (sensorSerialNumber) {
                const sensor = await this.findSensorBySerialNumber(sensorSerialNumber);
                sensorId = sensor.id;
            }

            // Build WHERE conditions dynamically
            let whereClause = `WHERE sr.timestamp >= '${startTime.toISOString()}' AND sr.timestamp <= '${endTime.toISOString()}'`;

            if (sensorId) {
                whereClause += ` AND sr.sensor_id = ${sensorId}`;
            }

            if (stationId) {
                whereClause += ` AND s.station_id = ${stationId}`;
            }

            if (sensorType) {
                whereClause += ` AND s.type = '${sensorType}'`;
            }

            const sqlQuery = `
        SELECT
          s.serial_number as "sensorSerialNumber",
          s.type as "sensorType",
          DATE_TRUNC('hour', sr.timestamp) as time_bucket,
          AVG(sr.value) as average,
          MIN(sr.value) as min,
          MAX(sr.value) as max,
          COUNT(*) as sample_count
        FROM sensor_readings sr
        JOIN sensors s ON sr.sensor_id = s.id
        ${whereClause}
        GROUP BY s.serial_number, s.type, time_bucket
        ORDER BY time_bucket ASC
      `;

            const result = await this.prisma.$queryRawUnsafe(sqlQuery);
            return result;
        } catch (error) {
            this.logger.error(`Failed to get aggregated data: ${error.message}`, error.stack);
            throw error;
        }
    }

    /**
     * Validate data quality based on multiple factors
     */
    async validateDataQuality(sensorSerialNumber: string, hours: number = 24) {
        try {
            const sensor = await this.findSensorBySerialNumber(sensorSerialNumber);
            const startTime = new Date(Date.now() - hours * 60 * 60 * 1000);

            const readings = await this.prisma.sensorReading.findMany({
                where: {
                    sensorId: sensor.id,
                    timestamp: {
                        gte: startTime,
                    },
                },
                orderBy: {
                    timestamp: 'asc',
                },
            });

            if (readings.length === 0) {
                return {
                    isValid: false,
                    score: 0,
                    issues: ['No data available for the specified period'],
                };
            }

            const issues: string[] = [];
            let qualityScore = 0;

            // Check for data gaps
            const gaps: DataGap[] = this.detectDataGaps(readings);
            if (gaps.length > 0) {
                issues.push(`Found ${gaps.length} data gaps in the time series`);
                qualityScore -= gaps.length * 0.1;
            }

            // Check for stale data
            const lastReading = readings[readings.length - 1];
            const timeSinceLastReading = Date.now() - lastReading.timestamp.getTime();
            const staleThreshold = 2 * 60 * 60 * 1000; // 2 hours

            if (timeSinceLastReading > staleThreshold) {
                issues.push('Data appears to be stale');
                qualityScore -= 0.3;
            }

            // Calculate average quality from readings
            const avgQuality = readings.reduce((sum, reading) => sum + (reading.quality || 0), 0) / readings.length;
            qualityScore += avgQuality;

            // Check for anomalous patterns (simple version)
            const anomalies: Anomaly[] = this.detectAnomalies(readings);
            if (anomalies.length > 0) {
                issues.push(`Detected ${anomalies.length} potential anomalies`);
                qualityScore -= anomalies.length * 0.05;
            }

            const finalScore = Math.max(0, Math.min(1, qualityScore));

            return {
                isValid: finalScore >= 0.7,
                score: finalScore,
                issues: issues.length > 0 ? issues : ['No quality issues detected'],
                readingsCount: readings.length,
                period: {
                    start: startTime,
                    end: new Date(),
                },
                sensor: {
                    serialNumber: sensor.serialNumber,
                    type: sensor.type,
                    name: sensor.name,
                },
            };
        } catch (error) {
            this.logger.error(`Failed to validate data quality: ${error.message}`, error.stack);
            throw error;
        }
    }

    /**
     * Process raw sensor data and convert to structured readings
     */
    async processRawSensorData(): Promise<SensorReadingResponseDto[]> {
        try {
            const unprocessedData = await this.prisma.rawSensorData.findMany({
                where: {
                    processed: false,
                },
                include: {
                    sensor: true,
                },
                take: 100, // Process in batches
            });

            const processedReadings: SensorReadingResponseDto[] = [];

            for (const rawData of unprocessedData) {
                try {
                    // Extract values from raw payload
                    const reading = this.extractReadingFromPayload(rawData.rawPayload, rawData.sensor);

                    if (reading) {
                        const createdReading = await this.createReading({
                            sensorSerialNumber: rawData.sensor.serialNumber,
                            value: reading.value,
                            unit: reading.unit,
                            timestamp: rawData.receivedAt,
                            quality: reading.quality,
                        });

                        processedReadings.push(createdReading);

                        // Mark as processed
                        await this.prisma.rawSensorData.update({
                            where: { id: rawData.id },
                            data: { processed: true },
                        });
                    }
                } catch (error) {
                    this.logger.error(`Failed to process raw data ${rawData.id}: ${error.message}`);
                    // Optionally mark as processed with error flag or leave for retry
                }
            }

            this.logger.log(`Processed ${processedReadings.length} raw sensor data entries`);
            return processedReadings;
        } catch (error) {
            this.logger.error(`Failed to process raw sensor data: ${error.message}`, error.stack);
            throw error;
        }
    }

    // Private helper methods

    private getSeverityWeight(severity: AlertSeverity): number {
        const weights = {
            [AlertSeverity.LOW]: 0.1,
            [AlertSeverity.MEDIUM]: 0.3,
            [AlertSeverity.HIGH]: 0.6,
            [AlertSeverity.CRITICAL]: 1.0,
        };
        return weights[severity] || 0;
    }

    /**
     * Create threshold alerts using StationAlertService with deduplication
     */
    private async createThresholdAlerts(reading: any, violations: any[], sensorType: SensorType) {
        for (const violation of violations) {
            try {
                // Determine which threshold value was exceeded
                const thresholdValue = this.getExceededThresholdValue(violation, reading.value);

                // Generate descriptive message
                const message = this.generateAlertMessage(violation, reading.value, sensorType);

                const alertPayload: CreateAlertInternalDto = {
                    stationId: reading.sensor.stationId,
                    sensorId: reading.sensorId,
                    sensorType: sensorType,
                    value: reading.value,
                    thresholdValue: thresholdValue,
                    severity: violation.severity,
                    message: message,
                };

                await this.stationAlertService.createAlertIfThresholdExceeded(alertPayload);

                this.logger.log(`Created alert for sensor ${reading.sensor.serialNumber} with severity ${violation.severity}`);
            } catch (error) {
                this.logger.error(`Failed to create alert for violation: ${error.message}`, error.stack);
            }
        }
    }

    /**
     * Determine which threshold value was exceeded and return it
     */
    private getExceededThresholdValue(violation: any, actualValue: number): number {
        if (violation.minValue !== null && actualValue < violation.minValue) {
            return violation.minValue;
        }
        if (violation.maxValue !== null && actualValue > violation.maxValue) {
            return violation.maxValue;
        }
        // Fallback - should not happen if violation is valid
        return violation.minValue ?? violation.maxValue ?? actualValue;
    }

    /**
     * Generate descriptive alert message
     */
    private generateAlertMessage(violation: any, actualValue: number, sensorType: SensorType): string {
        const sensorTypeName = sensorType.toLowerCase().replace('_', ' ');

        if (violation.minValue !== null && actualValue < violation.minValue) {
            return `Sensor ${sensorTypeName} reading ${actualValue} is below minimum threshold ${violation.minValue}. ${violation.description || ''}`.trim();
        }

        if (violation.maxValue !== null && actualValue > violation.maxValue) {
            return `Sensor ${sensorTypeName} reading ${actualValue} is above maximum threshold ${violation.maxValue}. ${violation.description || ''}`.trim();
        }

        return `Sensor ${sensorTypeName} reading ${actualValue} exceeded threshold. ${violation.description || ''}`.trim();
    }

    private detectDataGaps(readings: SensorReading[]): DataGap[] {
        const gaps: DataGap[] = [];
        for (let i = 1; i < readings.length; i++) {
            const timeDiff = readings[i].timestamp.getTime() - readings[i - 1].timestamp.getTime();
            // Consider gaps larger than 2 hours as significant
            if (timeDiff > 2 * 60 * 60 * 1000) {
                gaps.push({
                    before: readings[i - 1].timestamp,
                    after: readings[i].timestamp,
                    duration: timeDiff,
                });
            }
        }
        return gaps;
    }

    private detectAnomalies(readings: SensorReading[]): Anomaly[] {
        // Simple anomaly detection based on standard deviation
        const values = readings.map(r => r.value);
        const mean = values.reduce((a, b) => a + b) / values.length;
        const stdDev = Math.sqrt(values.reduce((sq, n) => sq + Math.pow(n - mean, 2), 0) / values.length);

        const anomalies: Anomaly[] = [];
        readings.forEach((reading, index) => {
            if (Math.abs(reading.value - mean) > 3 * stdDev) {
                anomalies.push({
                    index,
                    value: reading.value,
                    timestamp: reading.timestamp,
                });
            }
        });
        return anomalies;
    }

    private extractReadingFromPayload(payload: any, sensor: any) {
        // Implement based on your specific sensor data format
        try {
            if (payload.value !== undefined) {
                return {
                    value: parseFloat(payload.value),
                    unit: payload.unit || this.getDefaultUnit(sensor.type),
                    quality: payload.quality || 1.0,
                };
            }
            return null;
        } catch (error) {
            this.logger.error(`Failed to extract reading from payload: ${error.message}`);
            return null;
        }
    }
    private getDefaultUnit(sensorType: SensorType): string {
        const units = {
            [SensorType.TEMPERATURE]: '¬∞C',
            [SensorType.HUMIDITY]: '%',
            [SensorType.CO2]: 'ppm',
            [SensorType.AIR_QUALITY]: 'AQI',
            [SensorType.PM2_5]: '¬µg/m¬≥',
            [SensorType.PM10]: '¬µg/m¬≥',
            [SensorType.PRESSURE]: 'hPa',
            [SensorType.NOISE]: 'dB',
            [SensorType.WATER_QUALITY]: 'NTU',
        };
        return units[sensorType] || 'unit';
    }
}
 


–î–æ–¥–∞—Ç–æ–∫ –ë
–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –º–æ–Ω—ñ—Ç–æ—Ä–∏–Ω–≥–æ–≤–æ—ó —Å—Ç–∞–Ω—Ü—ñ—ó
 

@Injectable()
export class MonitoringStationStatsService {
    constructor(
        private prisma: PrismaService,
        private settingsService: SettingsService,
        private unitConversion: UnitConversionService,
    ) {}

    async getStationStats(stationId: number, token: string): Promise<StationStatsDto> {
        const userSettings = await this.settingsService.get(token);
        const userUnitSystem = userSettings?.measurementUnit || 'metric';
        const storageUnitSystem = this.unitConversion.getStorageUnitSystem();

        // Get station data with related entities
        const station: any = await this.prisma.monitoringStation.findUnique({
            where: { id: stationId },
            include: {
                sensors: {
                    where: { isActive: true },
                    include: {
                        readings: {
                            orderBy: { timestamp: 'desc' },
                            take: 1,
                        },
                        statusHistory: {
                            orderBy: { lastCheck: 'desc' },
                            take: 1,
                        },
                    },
                },
                aggregated: {
                    where: {
                        timeRange: '24h',
                        startTime: {
                            gte: new Date(Date.now() - 24 * 60 * 60 * 1000),
                        },
                    },
                    orderBy: { startTime: 'desc' },
                },
                stationAlerts: {
                    where: {
                        isActive: true,
                        createdAt: {
                            gte: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000),
                        },
                    },
                    orderBy: { createdAt: 'desc' },
                    take: 50,
                },
                maintenanceSchedules: {
                    where: {
                        isCompleted: false,
                        startDate: { gte: new Date() },
                    },
                    orderBy: { startDate: 'asc' },
                    take: 10,
                },
            },
        } as any );

        if (!station) {
            throw new NotFoundException(`Monitoring station with ID ${stationId} not found`);
        }

        // Process sensor data with unit conversion
        const processedSensors = station.sensors.map(sensor => {
            const lastReading = sensor.readings[0];
            const status = sensor.statusHistory[0];

            let processedReading: StationStatsDto['sensors'][0]['lastReading'] | undefined = undefined;

            if (lastReading) {
                const converted = this.unitConversion.convertValue(
                    lastReading.value,
                    sensor.type,
                    {
                        fromUnit: storageUnitSystem,
                        toUnit: userUnitSystem as 'metric' | 'imperial'
                    }
                );
                processedReading = {
                    value: converted.value,
                    unit: converted.unit,
                    timestamp: lastReading.timestamp,
                    quality: lastReading.quality ?? undefined,
                };
            }

            return {
                id: sensor.id,
                name: sensor.name,
                type: sensor.type,
                isActive: sensor.isActive,
                lastReading: processedReading,
                status: status ? {
                    isOnline: status.isOnline,
                    battery: status.battery ?? undefined,
                    signal: status.signal ?? undefined,
                    lastCheck: status.lastCheck,
                } : undefined,
            };
        });

        // Process aggregated data
        const processedAggregated = station.aggregatedData.map(agg => {
            const convertedAvg = this.unitConversion.convertValue(
                agg.average,
                agg.sensorType,
                { fromUnit: storageUnitSystem, toUnit: userUnitSystem as 'metric' | 'imperial' }
            );
            const convertedMin = this.unitConversion.convertValue(
                agg.minValue,
                agg.sensorType,
                { fromUnit: storageUnitSystem, toUnit: userUnitSystem as 'metric' | 'imperial' }
            );
            const convertedMax = this.unitConversion.convertValue(
                agg.maxValue,
                agg.sensorType,
                { fromUnit: storageUnitSystem, toUnit: userUnitSystem as 'metric' | 'imperial' }
            );
            return {
                sensorType: agg.sensorType,
                timeRange: agg.timeRange,
                average: convertedAvg.value,
                minValue: convertedMin.value,
                maxValue: convertedMax.value,
                stdDev: agg.stdDev ?? undefined,
                unit: convertedAvg.unit,
                startTime: agg.startTime,
                endTime: agg.endTime,
            };
        });

        // Process alerts with unit conversion
        const processedAlerts = station.stationAlerts.map(alert => {
            const convertedValue = this.unitConversion.convertValue(
                alert.value,
                alert.sensorType,
                { fromUnit: storageUnitSystem, toUnit: userUnitSystem as 'metric' | 'imperial' }
            );
            const convertedThreshold = this.unitConversion.convertValue(
                alert.thresholdValue,
                alert.sensorType,
                { fromUnit: storageUnitSystem, toUnit: userUnitSystem as 'metric' | 'imperial' }
            );

            return {
                id: alert.id,
                sensorType: alert.sensorType,
                value: convertedValue.value,
                thresholdValue: convertedThreshold.value,
                severity: alert.severity,
                message: alert.message,
                isActive: alert.isActive,
                acknowledged: alert.acknowledged,
                createdAt: alert.createdAt,
            };
        });

        // Process maintenance schedule
        const processedMaintenance = station.maintenanceSchedules.map(maintenance => ({
            id: maintenance.id,
            title: maintenance.title,
            description: maintenance.description ?? undefined,
            scheduleType: maintenance.scheduleType,
            startDate: maintenance.startDate,
            endDate: maintenance.endDate ?? undefined,
            isCompleted: maintenance.isCompleted,
        }));

        // Calculate summary
        const onlineSensors = processedSensors.filter(sensor => sensor.status?.isOnline).length;
        const activeAlerts = processedAlerts.filter(alert => alert.isActive).length;
        const criticalAlerts = processedAlerts.filter(alert =>
            alert.isActive && alert.severity === AlertSeverity.CRITICAL
        ).length;

        const summary = {
            totalSensors: processedSensors.length,
            activeSensors: processedSensors.filter(s => s.isActive).length,
            onlineSensors,
            activeAlerts,
            criticalAlerts,
            upcomingMaintenance: processedMaintenance.length,
        };

        return {
            station: {
                id: station.id,
                name: station.name,
                description: station.description ?? undefined,
                latitude: station.latitude,
                longitude: station.longitude,
                address: station.address ?? undefined,
                isActive: station.isActive,
                createdAt: station.createdAt,
            },
            sensors: processedSensors,
            aggregatedData: processedAggregated,
            alerts: processedAlerts,
            maintenance: processedMaintenance,
            summary,
        };
    }

    async getSensorTypeStats(stationId: number, sensorType: SensorType, token: string) {
        const userSettings = await this.settingsService.get(token);
        const userUnitSystem = userSettings?.measurementUnit || 'metric';
        const storageUnitSystem = this.unitConversion.getStorageUnitSystem();

        const stats = await this.prisma.aggregatedData.findMany({
            where: {
                stationId: stationId,
                sensorType: sensorType,
                startTime: {
                    gte: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000), // last 7 days
                },
            },
            orderBy: { startTime: 'asc' },
        } as any );

        return stats.map(stat => {
            const convertedAvg = this.unitConversion.convertValue(
                stat.average,
                stat.sensorType,
                { fromUnit: storageUnitSystem, toUnit: userUnitSystem as 'metric' | 'imperial' }
            );
            const convertedMin = this.unitConversion.convertValue(
                stat.minValue,
                stat.sensorType,
                { fromUnit: storageUnitSystem, toUnit: userUnitSystem as 'metric' | 'imperial' }
            );
            const convertedMax = this.unitConversion.convertValue(
                stat.maxValue,
                stat.sensorType,
                { fromUnit: storageUnitSystem, toUnit: userUnitSystem as 'metric' | 'imperial' }
            );

            return {
                timeRange: stat.timeRange,
                average: convertedAvg.value,
                minValue: convertedMin.value,
                maxValue: convertedMax.value,
                stdDev: stat.stdDev ?? undefined,
                unit: convertedAvg.unit,
                startTime: stat.startTime,
                endTime: stat.endTime,
            };
        });
    }

    async getStationHealth(stationId: number) {
        const station: any = await this.prisma.monitoringStation.findUnique({
            where: { id: stationId },
            include: {
                sensors: {
                    include: {
                        statusHistory: {
                            orderBy: { lastCheck: 'desc' },
                            take: 1,
                        },
                    },
                },
                stationAlerts: {
                    where: { isActive: true },
                },
            },
        } as any);

        if (!station) {
            throw new NotFoundException(`Station with ID ${stationId} not found`);
        }

        const totalSensors = station.sensors.length;
        const onlineSensors = station.sensors.filter(s => {
            const latestStatus = s.statusHistory[0];
            return latestStatus?.isOnline === true;
        }).length;
        const activeAlerts = station.stationAlerts.length;

        // Calculate health score (0-100)
        const baseScore = 100;
        const offlinePenalty = totalSensors > 0 ?
            ((totalSensors - onlineSensors) / totalSensors) * 40 : 0;
        const alertPenalty = Math.min(activeAlerts * 10, 30);

        const healthScore = Math.max(0, baseScore - offlinePenalty - alertPenalty);

        return {
            healthScore: Math.round(healthScore),
            status: this.getHealthStatus(healthScore),
            onlineSensors,
            totalSensors,
            activeAlerts,
            lastUpdated: new Date(),
        };
    }

    private getHealthStatus(score: number): 'EXCELLENT' | 'GOOD' | 'FAIR' | 'POOR' | 'CRITICAL' {
        if (score >= 90) return 'EXCELLENT';
        if (score >= 75) return 'GOOD';
        if (score >= 60) return 'FAIR';
        if (score >= 40) return 'POOR';
        return 'CRITICAL';
    }
}

 
 
























–î–æ–¥–∞—Ç–æ–∫ –í
–ü–µ—Ä–µ–≤–µ–¥–µ–Ω–Ω—è –º—ñ–∂ —Å–∏—Å—Ç–µ–º–∞–º–∏ –≤–∏–º—ñ—Ä—é–≤–∞–Ω–Ω—è

 
export interface ConversionResult {
    value: number;
    unit: string;
}

export interface ConversionOptions {
    fromUnit: 'metric' | 'imperial';
    toUnit: 'metric' | 'imperial';
}

@Injectable()
export class UnitConversionService {
    convertValue(
        value: number,
        sensorType: SensorType,
        options: ConversionOptions
    ): ConversionResult {
        if (options.fromUnit === options.toUnit) {
            // If the units are the same, return as is with the correct unit.
            return options.fromUnit === 'metric'
                ? this.toMetric(value, sensorType)
                : this.toImperial(value, sensorType);
        }

        if (options.fromUnit === 'metric' && options.toUnit === 'imperial') {
            return this.metricToImperial(value, sensorType);
        } else {
            return this.imperialToMetric(value, sensorType);
        }
    }

    private metricToImperial(value: number, sensorType: SensorType): ConversionResult {
        switch (sensorType) {
            case SensorType.TEMPERATURE:
                // Celsius to Fahrenheit
                return { value: (value * 9/5) + 32, unit: '¬∞F' };

            case SensorType.PRESSURE:
                // hPa ‚Üí inHg
                return { value: value * 0.02953, unit: 'inHg' };

            case SensorType.PM2_5:
            case SensorType.PM10:
                // ¬µg/m¬≥ the same
                return { value, unit: '¬µg/m¬≥' };

            case SensorType.NOISE:
                return { value, unit: 'dB' };

            case SensorType.HUMIDITY:
                return { value, unit: '%' };

            case SensorType.CO2:
                return { value, unit: 'ppm' };

            case SensorType.AIR_QUALITY:
                // Air Quality Index (no units)
                return { value, unit: 'AQI' };

            case SensorType.WATER_QUALITY:
                // Water Quality Index (no units)
                return { value, unit: 'WQI' };

            default:
                return { value, unit: '' };
        }
    }

    private imperialToMetric(value: number, sensorType: SensorType): ConversionResult {
        switch (sensorType) {
            case SensorType.TEMPERATURE:
                // Fahrenheit to Celsius
                return { value: (value - 32) * 5/9, unit: '¬∞C' };

            case SensorType.PRESSURE:
                // inHg ‚Üí hPa
                return { value: value / 0.02953, unit: 'hPa' };

            case SensorType.PM2_5:
            case SensorType.PM10:
                return { value, unit: '¬µg/m¬≥' };

            case SensorType.NOISE:
                return { value, unit: 'dB' };

            case SensorType.HUMIDITY:
                return { value, unit: '%' };

            case SensorType.CO2:
                return { value, unit: 'ppm' };

            case SensorType.AIR_QUALITY:
                return { value, unit: 'AQI' };

            case SensorType.WATER_QUALITY:
                return { value, unit: 'WQI' };

            default:
                return { value, unit: '' };
        }
    }

    private toMetric(value: number, sensorType: SensorType): ConversionResult {
        switch (sensorType) {
            case SensorType.TEMPERATURE:
                return { value, unit: '¬∞C' };

            case SensorType.PRESSURE:
                return { value, unit: 'hPa' };

            case SensorType.PM2_5:
            case SensorType.PM10:
                return { value, unit: '¬µg/m¬≥' };

            case SensorType.NOISE:
                return { value, unit: 'dB' };

            case SensorType.HUMIDITY:
                return { value, unit: '%' };

            case SensorType.CO2:
                return { value, unit: 'ppm' };

            case SensorType.AIR_QUALITY:
                return { value, unit: 'AQI' };

            case SensorType.WATER_QUALITY:
                return { value, unit: 'WQI' };

            default:
                return { value, unit: '' };
        }
    }

    private toImperial(value: number, sensorType: SensorType): ConversionResult {
        switch (sensorType) {
            case SensorType.TEMPERATURE:
                return { value, unit: '¬∞F' };

            case SensorType.PRESSURE:
                return { value, unit: 'inHg' };

            case SensorType.PM2_5:
            case SensorType.PM10:
                return { value, unit: '¬µg/m¬≥' };

            case SensorType.NOISE:
                return { value, unit: 'dB' };

            case SensorType.HUMIDITY:
                return { value, unit: '%' };

            case SensorType.CO2:
                return { value, unit: 'ppm' };

            case SensorType.AIR_QUALITY:
                return { value, unit: 'AQI' };

            case SensorType.WATER_QUALITY:
                return { value, unit: 'WQI' };

            default:
                return { value, unit: '' };
        }
    }

    // Method for determining which system stores data in a database
    getStorageUnitSystem(): 'metric' | 'imperial' {

        return 'metric';
    }

    // A simplified method for backward compatibility
    convertValueSimple(value: number, sensorType: SensorType, targetUnit: string): ConversionResult {
        const storageSystem = this.getStorageUnitSystem();

        return this.convertValue(value, sensorType, {
            fromUnit: storageSystem,
            toUnit: targetUnit as 'metric' | 'imperial'
        });
    }

    getDefaultUnit(sensorType: SensorType, measurementUnit: string): string {
        return measurementUnit === 'metric'
            ? this.toMetric(0, sensorType).unit
            : this.toImperial(0, sensorType).unit;
    }

    // Method for obtaining units of measurement in a storage system
    getStorageUnit(sensorType: SensorType): string {
        const storageSystem = this.getStorageUnitSystem();
        return storageSystem === 'metric'
            ? this.toMetric(0, sensorType).unit
            : this.toImperial(0, sensorType).unit;
    }
}
 
‚ÄÉ
–î–æ–¥–∞—Ç–æ–∫ –ì
–†–µ–∑–µ—Ä–≤–Ω—ñ –∫–æ–ø—ñ—ó

 
@Injectable()
export class BackupService {
    private readonly logger = new Logger(BackupService.name);
    private readonly backupDirectory = path.join(process.cwd(), 'backups');
    private activeBackupProcesses: Map<number, child_process.ChildProcess> = new Map();

    constructor(private readonly prisma: PrismaService) {
        this.ensureBackupDirectory();
    }

    /**
     * Ensures backup directory exists
     */
    private async ensureBackupDirectory(): Promise<void> {
        try {
            await fsPromises.access(this.backupDirectory);
        } catch {
            await fsPromises.mkdir(this.backupDirectory, { recursive: true });
            this.logger.log(`Created backup directory: ${this.backupDirectory}`);
        }
    }

    /**
     * Creates a new backup based on type
     */
    async createBackup(
        type: 'database' | 'full' = 'database',
        description?: string,
    ): Promise<any> {
        // Create backup record in database
        const backupRecord = await this.prisma.systemBackup.create({
            data: {
                fileName: '',
                filePath: '',
                status: BackupStatus.PENDING,
                description,
                startedAt: new Date(),
            },
        });

        try {
            let result;
            if (type === 'full') {
                result = await this.createFullBackupInternal(backupRecord.id);
            } else {
                result = await this.createDatabaseBackupInternal(backupRecord.id);
            }

            return result;
        } catch (error) {
            this.logger.error(`Backup creation failed: ${error.message}`, error.stack);
            throw error;
        }
    }

    /**
     * Creates database backup (internal method)
     */
    private async createDatabaseBackupInternal(backupId: number): Promise<any> {
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
        const fileName = `db-backup-${timestamp}.sql`;
        const filePath = path.join(this.backupDirectory, fileName);

        try {
            // Update record with initial file info
            await this.prisma.systemBackup.update({
                where: { id: backupId },
                data: { fileName, filePath },
            });

            const databaseUrl = process.env.DATABASE_URL;
            if (!databaseUrl) {
                throw new Error('DATABASE_URL environment variable is not set');
            }

            // Parse database URL
            const url = new URL(databaseUrl);
            const dbName = url.pathname.slice(1);
            const dbHost = url.hostname;
            const dbPort = url.port || '5432';
            const dbUser = url.username;
            const dbPassword = url.password;

            // Create pg_dump command for PostgreSQL
            const dumpCommand = `PGPASSWORD="${dbPassword}" pg_dump -h ${dbHost} -p ${dbPort} -U ${dbUser} -d ${dbName} -F c -f ${filePath}`;

            this.logger.log(`Starting database backup: ${fileName}`);

            // Execute backup command
            const childProcess = child_process.exec(dumpCommand, { maxBuffer: 1024 * 1024 * 10 });
            this.activeBackupProcesses.set(backupId, childProcess);

            await new Promise((resolve, reject) => {
                childProcess.on('exit', (code) => {
                    this.activeBackupProcesses.delete(backupId);
                    if (code === 0) {
                        resolve(null);
                    } else {
                        reject(new Error(`Backup process exited with code ${code}`));
                    }
                });
                childProcess.on('error', reject);
            });

            // Get file size
            const stats = await fsPromises.stat(filePath);
            const fileSizeMB = stats.size / (1024 * 1024);

            // Update backup record with success details
            const updatedBackup = await this.prisma.systemBackup.update({
                where: { id: backupId },
                data: {
                    fileSize: parseFloat(fileSizeMB.toFixed(2)),
                    status: BackupStatus.COMPLETED,
                    completedAt: new Date(),
                },
            });

            this.logger.log(`Database backup completed: ${fileName} (${fileSizeMB.toFixed(2)} MB)`);
            return updatedBackup;
        } catch (error) {
            // Update backup record with error details
            await this.prisma.systemBackup.update({
                where: { id: backupId },
                data: {
                    status: BackupStatus.FAILED,
                    errorMessage: error.message,
                    completedAt: new Date(),
                },
            });
            throw error;
        }
    }

    /**
     * Creates full system backup (internal method)
     */
    private async createFullBackupInternal(backupId: number): Promise<any> {
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
        const fileName = `full-backup-${timestamp}.tar.gz`;
        const filePath = path.join(this.backupDirectory, fileName);

        try {
            // Update record with initial file info
            await this.prisma.systemBackup.update({
                where: { id: backupId },
                data: { fileName, filePath },
            });

            // Define directories to include in backup
            const uploadsDir = path.join(process.cwd(), 'uploads');
            const tempDbDump = path.join(this.backupDirectory, `temp-db-${timestamp}.sql`);

            // Create database dump first
            const databaseUrl = process.env.DATABASE_URL;
            if (!databaseUrl) {
                throw new Error('DATABASE_URL environment variable is not set');
            }

            const url = new URL(databaseUrl);
            const dbName = url.pathname.slice(1);
            const dbHost = url.hostname;
            const dbPort = url.port || '5432';
            const dbUser = url.username;
            const dbPassword = url.password;

            // Dump database to temporary file
            const dumpCommand = `PGPASSWORD="${dbPassword}" pg_dump -h ${dbHost} -p ${dbPort} -U ${dbUser} -d ${dbName} > ${tempDbDump}`;

            const childProcess = child_process.exec(dumpCommand, { maxBuffer: 1024 * 1024 * 10 });
            this.activeBackupProcesses.set(backupId, childProcess);

            await new Promise((resolve, reject) => {
                childProcess.on('exit', (code) => {
                    if (code === 0) {
                        resolve(null);
                    } else {
                        reject(new Error(`Database dump process exited with code ${code}`));
                    }
                });
                childProcess.on('error', reject);
            });

            // Check if uploads directory exists
            let uploadsInclude = '';
            try {
                await fsPromises.access(uploadsDir);
                uploadsInclude = `-C ${process.cwd()} uploads`;
            } catch {
                this.logger.warn('Uploads directory not found, skipping');
            }

            // Create tar archive
            const tarCommand = `tar -czf ${filePath} -C ${this.backupDirectory} ${path.basename(tempDbDump)} ${uploadsInclude}`;
            const tarProcess = child_process.exec(tarCommand);

            await new Promise((resolve, reject) => {
                tarProcess.on('exit', (code) => {
                    this.activeBackupProcesses.delete(backupId);
                    if (code === 0) {
                        resolve(null);
                    } else {
                        reject(new Error(`Tar process exited with code ${code}`));
                    }
                });
                tarProcess.on('error', reject);
            });

            // Clean up temporary database dump
            await fsPromises.unlink(tempDbDump).catch(() => {
                this.logger.warn(`Could not delete temporary file: ${tempDbDump}`);
            });

            // Get file size
            const stats = await fsPromises.stat(filePath);
            const fileSizeMB = stats.size / (1024 * 1024);

            // Update backup record
            const updatedBackup = await this.prisma.systemBackup.update({
                where: { id: backupId },
                data: {
                    fileSize: parseFloat(fileSizeMB.toFixed(2)),
                    status: BackupStatus.COMPLETED,
                    completedAt: new Date(),
                },
            });

            this.logger.log(`Full backup completed: ${fileName} (${fileSizeMB.toFixed(2)} MB)`);
            return updatedBackup;
        } catch (error) {
            await this.prisma.systemBackup.update({
                where: { id: backupId },
                data: {
                    status: BackupStatus.FAILED,
                    errorMessage: error.message,
                    completedAt: new Date(),
                },
            });
            throw error;
        }
    }

    /**
     * Lists all backups with pagination
     */
    async listBackups(
        skip: number = 0,
        take: number = 10,
        status?: BackupStatus,
    ): Promise<any[]> {
        const where = status ? { status } : {};

        return this.prisma.systemBackup.findMany({
            where,
            skip,
            take,
            orderBy: { createdAt: 'desc' },
            select: {
                id: true,
                fileName: true,
                fileSize: true,
                status: true,
                description: true,
                createdAt: true,
                startedAt: true,
                completedAt: true,
            },
        });
    }

    /**
     * Gets backup by ID
     */
    async getBackup(id: number): Promise<any> {
        const backup = await this.prisma.systemBackup.findUnique({
            where: { id },
        });

        if (!backup) {
            throw new NotFoundException(`Backup with ID ${id} not found`);
        }

        return backup;
    }

    /**
     * Cancels an in-progress backup
     */
    async cancelBackup(id: number): Promise<any> {
        const backup = await this.prisma.systemBackup.findUnique({
            where: { id },
        });

        if (!backup) {
            throw new NotFoundException(`Backup with ID ${id} not found`);
        }

        if (backup.status !== BackupStatus.PENDING) {
            throw new Error(`Cannot cancel backup with status ${backup.status}`);
        }

        // Kill the backup process if it exists
        const process = this.activeBackupProcesses.get(id);
        if (process) {
            process.kill('SIGTERM');
            this.activeBackupProcesses.delete(id);
        }

        // Update backup status
        const updatedBackup = await this.prisma.systemBackup.update({
            where: { id },
            data: {
                status: BackupStatus.CANCELLED,
                completedAt: new Date(),
                errorMessage: 'Backup cancelled by user',
            },
        });

        this.logger.log(`Backup ${id} cancelled`);
        return updatedBackup;
    }

    /**
     * Gets backup file stream for download
     */
    async getBackupFileStream(id: number): Promise<{ stream: fs.ReadStream; fileName: string }> {
        const backup = await this.prisma.systemBackup.findUnique({
            where: { id },
        });

        if (!backup) {
            throw new NotFoundException(`Backup with ID ${id} not found`);
        }

        if (backup.status !== BackupStatus.COMPLETED) {
            throw new Error(`Backup with status ${backup.status} cannot be downloaded`);
        }

        if (!backup.filePath) {
            throw new Error('Backup file path not found');
        }

        try {
            await fsPromises.access(backup.filePath);
            const stream = fs.createReadStream(backup.filePath);
            return { stream, fileName: backup.fileName };
        } catch (error) {
            throw new NotFoundException(`Backup file not found: ${backup.filePath}`);
        }
    }

    /**
     * Deletes backup record and file
     */
    async deleteBackup(id: number): Promise<void> {
        const backup = await this.prisma.systemBackup.findUnique({
            where: { id },
        });

        if (!backup) {
            throw new NotFoundException(`Backup with ID ${id} not found`);
        }

        // Delete file if exists
        if (backup.filePath) {
            try {
                await fsPromises.unlink(backup.filePath);
            } catch (error) {
                this.logger.warn(`Could not delete backup file: ${backup.filePath}`, error.message);
            }
        }

        // Delete database record
        await this.prisma.systemBackup.delete({
            where: { id },
        });
    }

    /**
     * Gets backup statistics
     */
    async getBackupStats(): Promise<{
        total: number;
        completed: number;
        failed: number;
        pending: number;
        cancelled: number;
        totalSizeMB: number;
    }> {
        const backups = await this.prisma.systemBackup.findMany();
        const completedBackups = backups.filter(b => b.status === BackupStatus.COMPLETED);

        return {
            total: backups.length,
            completed: completedBackups.length,
            failed: backups.filter(b => b.status === BackupStatus.FAILED).length,
            pending: backups.filter(b => b.status === BackupStatus.PENDING).length,
            cancelled: backups.filter(b => b.status === BackupStatus.CANCELLED).length,
            totalSizeMB: completedBackups
                .filter(b => b.fileSize)
                .reduce((sum, backup) => sum + (backup.fileSize || 0), 0),
        };
    }
}
 

