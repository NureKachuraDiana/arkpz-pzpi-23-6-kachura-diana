МІНІСТЕРСТВО ОСВІТИ І НАУКИ УКРАЇНИ

 
ХАРКІВСЬКИЙ НАЦІОНАЛЬНИЙ
УНІВЕРСИТЕТ РАДІОЕЛЕКТРОНІКИ



КАФЕДРА ПІ
  

ЗВІТ
з лабораторної роботи №5
з дисципліни «АНАЛІЗ ТА РЕФАКТОРИНГ 
КОДУ ПРОГРАМНОГО ЗАБЕЗПЕЧЕННЯ»
за темою «РОЗГОРТАННЯ ПРОГРАМНОЇ 
СИСТЕМИ ТА ДЕМОНСТРАЦІЯ ЇЇ РОБОТИ»



Виконала:                                          	             
ст. гр. ПЗПІ-23-6
Качура Діана	Прийняв:	
Асистент кафедри ПІ
Дашенков Д. С.






Харків 2025
5.1 Мета заняття

	Розгортання програмної системи та демонстрація її роботи
	
	5.2 Виконання завдання
	5.2.1 Налаштування безпеки

У програмній системі моніторингу екології реалізовано комплекс серверних налаштувань безпеки, спрямованих на захист переданих даних, контроль доступу клієнтських застосунків та валідацію вхідних запитів. Серверна частина розроблена з використанням фреймворку NestJS та підтримує як захищене, так і незахищене з’єднання залежно від умов розгортання.
Для забезпечення захищеної передачі даних реалізовано підтримку HTTPS з використанням SSL-сертифікатів. Під час запуску сервера здійснюється перевірка наявності файлів key.pem та cert.pem у директорії ssl. У разі їх наявності сервер автоматично запускається в режимі HTTPS із передачею ключа та сертифіката до параметрів створення застосунку. За відсутності сертифікатів система коректно переходить у режим HTTP, що дозволяє використовувати сервер у локальному або тестовому середовищі без зупинки роботи.
Для роботи з HTTP-cookie використовується проміжне програмне забезпечення cookie-parser, яке забезпечує коректну обробку сесійних та автентифікаційних даних користувачів. Це є необхідною умовою для реалізації серверної авторизації та підтримки сесій.
Контроль міждоменного доступу реалізовано за допомогою механізму CORS. У конфігурації сервера визначено перелік дозволених джерел запитів, зокрема локальні адреси клієнтських застосунків (React / Next.js) та платформа симуляції IoT-пристроїв Wokwi. Перевірка джерела (origin) виконується динамічно: сервер дозволяє запити лише з попередньо визначених доменів або з локального середовища розробки. У випадку спроби доступу з несанкціонованого джерела запит блокується. Також дозволено обробку запитів без вказаного origin, що є типовим для мобільних клієнтів або інструментів тестування API (Postman).
Для захисту API від некоректних або небезпечних даних застосовано глобальний механізм валідації вхідних параметрів за допомогою ValidationPipe. Дана конфігурація забезпечує автоматичне приведення типів даних та перевірку відповідності параметрів визначеним DTO-схемам, що знижує ризик помилок виконання та атак, пов’язаних із передачею некоректних даних.
Окремо реалізовано другий HTTP-сервер для інтеграції з IoT-симулятором Wokwi, який не підтримує HTTPS-з’єднання. Для цього сервер запускається на окремому порту з відкритим CORS-доступом та обмеженою конфігурацією без використання облікових даних користувача. Такий підхід дозволяє ізолювати канали збору телеметричних даних від основного захищеного API та підвищити загальний рівень безпеки системи.

5.2.2 Налаштування взаємодії Wokwi з серверною частиною

Для забезпечення обміну даними між IoT-пристроєм та серверною частиною програмної системи моніторингу екології використовується платформа симуляції вбудованих систем Wokwi. Дана платформа дозволяє емулювати роботу мікроконтролера та передавати вимірювані сенсорні дані на сервер у режимі реального часу.
Для організації взаємодії необхідно встановити та запустити утиліту Wokwi на локальному персональному комп’ютері. Після запуску утиліти створюється віртуальне середовище, у межах якого IoT-проєкт отримує доступ до локального серверного застосунку.
У конфігурації IoT-проєкту задається мережевий ендпоінт серверної частини, на який передаються дані з датчиків. Оскільки симулятор Wokwi працює у власному ізольованому середовищі, для доступу до локального сервера використовується спеціальне доменне ім’я host.wokwi.internal, яке забезпечує коректну маршрутизацію HTTP-запитів до хост-машини. Сервер приймає запити на окремому HTTP-порті, призначеному спеціально для взаємодії з Wokwi.
У коді мікроконтролера адреса серверного API задається у вигляді рядкової константи:
http://host.wokwi.internal:5195/sensor-readings,
де порт 5195 відповідає додатковому HTTP-серверу, а шлях /sensor-readings — ендпоінту приймання екологічних показників.
Передача даних здійснюється за протоколом HTTP з використанням запитів типу POST, що дозволяє серверній частині приймати, обробляти та зберігати показники сенсорів у базі даних. Відокремлення каналу взаємодії з Wokwi від основного API забезпечує стабільність роботи системи та спрощує тестування IoT-компонентів без впливу на клієнтські застосунки.

5.2.3 Налаштування клієнт-серверної взаємодії між серверною частиною Nest.js та клієнтською частиною Next.js

Клієнт-серверна взаємодія в програмній системі моніторингу екології реалізована за принципом REST-архітектури з використанням HTTP-запитів та формату обміну даними JSON. Серверна частина, розроблена на базі фреймворку NestJS, надає набір API-ендпоінтів, до яких звертається клієнтський веб-застосунок, реалізований з використанням Next.js.
Для централізованого та уніфікованого виконання HTTP-запитів на клієнтській стороні використовується бібліотека Axios. У клієнтському застосунку створено окремий екземпляр Axios, який інкапсулює всі налаштування взаємодії з сервером, включно з базовою адресою API, тайм-аутами, заголовками та обробкою помилок.
Базова адреса серверного API задається через змінну середовища NEXT_PUBLIC_API_BASE_URL, що відповідає вимогам Next.js щодо доступу до змінних на клієнтській стороні. За замовчуванням використовується захищене HTTPS-з’єднання з локальним сервером. Такий підхід забезпечує гнучкість конфігурації та дозволяє легко змінювати адресу серверу залежно від середовища виконання (розробка, тестування або продакшн) без зміни програмного коду.
Екземпляр Axios налаштований на використання параметра withCredentials, що дозволяє автоматично передавати HTTP-cookie разом із запитами. Це забезпечує коректну роботу сесійної автентифікації, реалізованої на серверній частині, та дозволяє серверу ідентифікувати автентифікованого користувача без явної передачі токенів у кожному запиті.
Для підвищення надійності взаємодії встановлено тайм-аут виконання запитів, а також визначено стандартні HTTP-заголовки, зокрема тип контенту application/json. Це забезпечує узгодженість формату даних між клієнтом і сервером.
У клієнтському застосунку реалізовано механізм інтерцепторів Axios, які дозволяють централізовано обробляти всі HTTP-запити та відповіді. Інтерцептор запитів використовується для можливого розширення функціональності (наприклад, додавання додаткових заголовків), тоді як інтерцептор відповідей відповідає за обробку помилок доступу.
Зокрема, у випадку отримання від сервера відповіді з кодом 401 Unauthorized, що свідчить про відсутність або завершення користувацької сесії, клієнтський застосунок автоматично перенаправляє користувача на сторінку авторизації. При цьому враховується поточний маршрут, що дозволяє уникнути циклічних перенаправлень та не порушує доступ до публічних сторінок системи.

5.2.4 Налаштування SSL сертифікатів

Для забезпечення захищеного обміну даними між клієнтською та серверною частинами програмної системи моніторингу екології використовується протокол HTTPS, який базується на застосуванні SSL-сертифікатів. Використання захищеного з’єднання дозволяє запобігти перехопленню даних, модифікації трафіку та несанкціонованому доступу до інформації під час її передачі мережею.
У межах лабораторної роботи застосовується підхід генерації локальних самопідписаних SSL-сертифікатів. Сертифікати створюються за допомогою утиліти npx generate cert, що дозволяє швидко згенерувати пару криптографічних ключів (приватний ключ та сертифікат) без залучення зовнішніх центрів сертифікації. Такий підхід є доцільним для локального середовища розробки та тестування.
Після генерації сертифікатів файли ключа та сертифіката зберігаються у відповідній директорії серверного проєкту та використовуються під час запуску серверної частини NestJS. Сервер автоматично перевіряє наявність SSL-файлів і, у разі їх успішного виявлення, запускається в режимі HTTPS. Це забезпечує прозорий перехід між HTTP та HTTPS залежно від конфігурації середовища виконання.
На клієнтській стороні Next.js доступ до серверного API налаштовано з урахуванням використання HTTPS-з’єднання. У випадку використання самопідписаних сертифікатів у локальному середовищі браузер може видавати попередження про довіру до сертифіката, що є очікуваною поведінкою та не впливає на функціональність системи в межах тестування.

5.2.5 Міграції даних Prisma

Для зберігання та обробки даних у програмній системі моніторингу екології використовується реляційна система управління базами даних PostgreSQL. Взаємодія серверної частини з базою даних реалізована за допомогою ORM-бібліотеки Prisma, яка забезпечує абстракцію доступу до даних, контроль схеми БД та підтримку механізму міграцій.
Підключення до бази даних PostgreSQL здійснюється через рядок з’єднання, який зберігається у файлі конфігурації середовища (.env). Рядок підключення містить необхідні параметри для автентифікації та доступу до БД, зокрема ім’я користувача, пароль, адресу сервера, порт та назву бази даних. Приклад рядка підключення має такий вигляд:
DATABASE_URL="postgresql://postgres:password@localhost:5432/eco_monitor"
У даному прикладі використовується локальний сервер PostgreSQL, стандартний порт 5432 та база даних eco_monitor. Зміна параметрів підключення дозволяє легко адаптувати систему до іншого середовища виконання без модифікації програмного коду.
Опис структури бази даних здійснюється у файлі schema.prisma, де визначаються моделі даних, їх поля, типи, зв’язки та обмеження цілісності. На основі цього опису Prisma формує та керує SQL-міграціями.
Для ініціалізації структури бази даних та застосування змін використовується механізм міграцій. Основною командою для створення та застосування міграцій є:
npx prisma migrate dev
Дана команда виконує аналіз поточного стану схеми, створює файли міграцій та автоматично застосовує їх до підключеної бази даних PostgreSQL. У процесі виконання формується необхідна структура таблиць, індексів та зв’язків, що забезпечує готовність бази даних до роботи з серверною частиною системи.

5.2.6 Налаштування мовної локалізації

У клієнтській частині програмної системи моніторингу екології реалізовано механізм мовної локалізації інтерфейсу, який забезпечує підтримку декількох мов та можливість їх динамічного перемикання без перезавантаження сторінки. Локалізація реалізована на рівні клієнтського застосунку Next.js із використанням контексту React.
Для зберігання та управління поточним станом мови створено глобальний LanguageContext, який надає доступ до обраної мови, функції її зміни та функції отримання перекладів (t) у будь-якому компоненті застосунку. Це дозволяє централізовано керувати мовними налаштуваннями та уникнути дублювання логіки локалізації.
Під час ініціалізації застосунку мова інтерфейсу зчитується з локального сховища браузера (localStorage). Для цього використовується спеціальний ключ, під яким зберігається вибір користувача. У разі відсутності збереженого значення застосовується мова за замовчуванням, визначена в конфігурації системи. Такий підхід забезпечує збереження мовних налаштувань між сесіями користувача.
Зміна мови здійснюється через функцію setLanguage, яка оновлює стан застосунку та зберігає нове значення у локальному сховищі. Додатково реалізовано синхронізацію атрибуту lang HTML-документа, що підвищує доступність інтерфейсу та коректність роботи допоміжних інструментів, зокрема екранних зчитувачів та пошукових систем.
Для отримання текстових ресурсів використовується функція t, яка забезпечує доступ до перекладів на основі поточної мови. Переклади зберігаються у структурованому вигляді, що дозволяє використовувати вкладені ключі та підтримувати масштабування словника без зміни клієнтської логіки. Такий підхід спрощує супровід і розширення мовної підтримки системи.
Окремо враховано особливості рендерингу в середовищі Next.js. Контекст локалізації надається всім дочірнім компонентам незалежно від етапу монтування, що дозволяє уникнути помилок доступу до контексту під час початкового рендерингу та забезпечує стабільну роботу інтерфейсу.

5.2.7 Написання скриптів для розгортання системи

З метою спрощення процесу розгортання, запуску та супроводу програмної системи моніторингу екології було розроблено набір npm-скриптів, які автоматизують основні етапи роботи з проєктом. Скрипти об’єднують процеси встановлення залежностей, генерації SSL-сертифікатів, запуску серверної та клієнтської частин у різних режимах, а також збірки та перевірки коду.
Для початкового налаштування проєкту передбачено скрипт install:all, який послідовно виконує встановлення залежностей у кореневому каталозі, серверній частині NestJS та клієнтській частині Next.js. Це дозволяє виконати повну ініціалізацію середовища однією командою та зменшує ймовірність помилок під час ручного встановлення пакетів. Додатково використовується скрипт postinstall, який інформує користувача про необхідність запуску повної інсталяції залежностей.
Для забезпечення захищеного з’єднання реалізовано скрипт generate:certs, який автоматизує процес генерації локальних SSL-сертифікатів окремо для серверної та клієнтської частин системи. Це дозволяє підготувати середовище до роботи в режимі HTTPS без ручного втручання.
Запуск системи у режимі розробки здійснюється за допомогою скриптів dev:http та dev:https, які паралельно запускають серверну та клієнтську частини за допомогою утиліти concurrently. Окремо передбачено скрипт dev:https:setup, який поєднує генерацію сертифікатів і запуск системи в HTTPS-режимі, що значно спрощує первинне налаштування.
Для більш гнучкого керування процесами розробки також реалізовано окремі скрипти запуску серверної (dev:server:http, dev:server:https) та клієнтської (dev:client:http, dev:client:https) частин. Такий підхід дозволяє запускати компоненти системи незалежно один від одного за потреби налагодження або тестування.
Процес підготовки системи до експлуатації автоматизовано за допомогою скрипта build, який виконує збірку серверної та клієнтської частин у відповідних каталогах. Для запуску системи у продукційному режимі передбачено скрипти start:http та start:https, які, аналогічно до режиму розробки, запускають обидві частини паралельно. Також реалізовано окремі скрипти запуску серверу та клієнта у продукційному середовищі.
Контроль якості коду забезпечується скриптом lint, який послідовно виконує перевірку серверної та клієнтської частин відповідно до визначених правил стилю та статичного аналізу.

5.2.8 Мануальне тестування функціональності, визначеної у розділі 2.2 Vision and Scope

З метою перевірки працездатності та коректності реалізації функціональних вимог, визначених у розділі 2.2 документа Vision and Scope, було проведено ручне тестування програмної системи моніторингу екології. Тестування виконувалося у локальному середовищі після повного розгортання серверної та клієнтської частин системи.
Ручне тестування здійснювалося шляхом послідовного виконання користувацьких сценаріїв, які відповідають основним функціям системи, визначеним на етапі формування вимог. Під час тестування перевірялася коректність взаємодії між клієнтською частиною та сервером, обробка вхідних даних, відображення інформації в інтерфейсі користувача та стабільність роботи системи в цілому.
Особливу увагу було приділено перевірці функціоналу, пов’язаного з отриманням та обробкою екологічних показників, їх передачею від IoT-джерел до серверної частини та подальшим відображенням результатів у клієнтському застосунку. Також було перевірено коректність роботи механізмів авторизації, навігації між сторінками, мовної локалізації інтерфейсу та обробки помилкових або граничних ситуацій.
Результати виконання основних тестових сценаріїв підтвердили відповідність реалізованого функціоналу вимогам, визначеним у розділі 2.2 Vision and Scope. Під час тестування критичних помилок, що перешкоджають роботі системи, виявлено не було. Демонстрація виконання тестових сценаріїв та підтвердження працездатності системи наведені у відеоматеріалі, який додається до звіту.


5.3 Висновок

У ході виконання лабораторної роботи було успішно розгорнуто програмну систему моніторингу екології, здійснено налаштування серверної та клієнтської частин, підключення до бази даних PostgreSQL, налаштовано захищене HTTPS-з’єднання за допомогою локально згенерованих SSL-сертифікатів та забезпечено підтримку мовної локалізації інтерфейсу.
Було реалізовано механізм клієнт-серверної взаємодії з використанням Axios, налаштовано управління сесійною автентифікацією та обробку помилок. Міграції даних за допомогою Prisma дозволили сформувати повністю функціональну базу даних, готову для роботи системи.
Ручне тестування підтвердило коректну роботу ключових функцій, визначених у документі Vision and Scope, зокрема обмін даними між клієнтською та серверною частинами, обробку екологічних показників, роботу механізмів авторизації та локалізації. Критичних помилок не виявлено, що засвідчує готовність системи до подальшої експлуатації.
 
ПЕРЕЛІК ДЖЕРЕЛ ПОСИЛАННЯ
1. GitHub - NureKachuraDiana/arkpz-pzpi-23-6-kachura-diana. GitHub. URL:  https://github.com/NureKachuraDiana/arkpz-pzpi-23-6-kachura-diana.
2. YouTube: https://youtu.be/L-PQzUCdDb4
 
Додаток А
Файл налаштувань безпеки серверної частини
 

async function bootstrap() {
  const PORT = process.env.PORT || 5193; // HTTPS
  const WOKWI_PORT = process.env.WOKWI_PORT || 5195; //  HTTP

  let appOptions: any = {};
  let httpsEnabled = false;

  // SSL paths
  const sslKeyPath = path.join(process.cwd(), 'ssl', 'key.pem');
  const sslCertPath = path.join(process.cwd(), 'ssl', 'cert.pem');

  // Check SSL availability
  if (fs.existsSync(sslKeyPath) && fs.existsSync(sslCertPath)) {
    appOptions = {
      httpsOptions: {
        key: fs.readFileSync(sslKeyPath),
        cert: fs.readFileSync(sslCertPath),
      },
    };
    httpsEnabled = true;
    console.log('SSL certificates found → starting HTTPS server');
  } else {
    console.warn('SSL certificates not found → starting HTTP server');
  }

  // Create main app (HTTPS or HTTP)
  const app = await NestFactory.create(AppModule, appOptions);

  // Swagger config
  const config = new DocumentBuilder()
      .setTitle('API')
      .setDescription('Eco-monitor api')
      .setVersion('1.0.0')
      .build();

  app.use(cookieParser());

  // CORS config - allow all localhost ports for development
  const allowedOrigins = [
    process.env.FRONTEND_URL || 'http://localhost:3000',
    'http://localhost:3000', // Next.js/React default port
    'http://localhost:3001', // Alternative port
    'http://localhost:3002', // Another alternative
    'https://localhost:3000', // HTTPS Next.js/React
    'https://localhost:3001', // HTTPS alternative
    'https://wokwi.com',
    'https://*.wokwi.com'
  ];

  app.enableCors({
    origin: (origin, callback) => {
      if (!origin) {
        return callback(null, true);
      }

      const allowedOrigins = [
        process.env.FRONTEND_URL || 'http://localhost:3000',
        'http://localhost:3000',
        'http://localhost:3001',
        'http://localhost:3002',
        'https://localhost:3000',
        'https://localhost:3001',
        'https://wokwi.com',
        'https://*.wokwi.com'
      ];

      if (allowedOrigins.some(allowed => {
        if (allowed.includes('*')) {
          const pattern = allowed.replace('*.', '');
          return origin.includes(pattern);
        }
        return origin === allowed;
      })) {
        callback(null, true);
      } else if (process.env.NODE_ENV !== 'production' && origin.includes('localhost')) {

        callback(null, true);
      } else {
        callback(new Error('Not allowed by CORS'));
      }
    },
    credentials: true,
    methods: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'OPTIONS'],
    allowedHeaders: [
      'Content-Type',
      'Authorization',
      'Cookie',
      'Set-Cookie',
      'ngrok-skip-browser-warning',
      'X-Requested-With',
      'Accept',
      'Origin'
    ],
    exposedHeaders: ['Set-Cookie', 'Authorization'],
    optionsSuccessStatus: 200,
    preflightContinue: false,
    maxAge: 86400,
  });

  app.useGlobalPipes(new ValidationPipe({
    transform: true,
    transformOptions: {
      enableImplicitConversion: true,
    },
  }));

  const document = SwaggerModule.createDocument(app, config);
  SwaggerModule.setup('api', app, document);

  // === MAIN SERVER (HTTPS or HTTP) ===
  await app.listen(PORT, '0.0.0.0');
  console.log(
      `Main server running on ${httpsEnabled ? 'https' : 'http'}://localhost:${PORT}`
  );

  // === SECOND HTTP SERVER FOR WOKWI ===
  // Wokwi does not support HTTPS, so we open a pure HTTP port
  const httpApp = await NestFactory.create(AppModule);
  httpApp.use(cookieParser());
  httpApp.enableCors({
    origin: '*',
    credentials: false,
    allowedHeaders: [
      'Content-Type', 
      'Authorization', 
      'Cookie',
      'ngrok-skip-browser-warning',
      'X-Requested-With'
    ],
  });

  await httpApp.listen(WOKWI_PORT, '0.0.0.0');
  console.log(`Wokwi HTTP server running on http://localhost:${WOKWI_PORT}`);
}

bootstrap();
 

